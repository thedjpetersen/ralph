// Code generated by ent, DO NOT EDIT.

package ent

import (
	"clockzen-next/internal/ent/receipt"
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

// Receipt is the model entity for the Receipt schema.
type Receipt struct {
	config `json:"-"`
	// ID of the ent.
	ID string `json:"id,omitempty"`
	// ID of the user who owns this receipt
	UserID string `json:"user_id,omitempty"`
	// Source of the receipt (email attachment, drive file, manual upload, or scanned)
	SourceType receipt.SourceType `json:"source_type,omitempty"`
	// ID of the source (email message ID, drive file ID, etc.)
	SourceID *string `json:"source_id,omitempty"`
	// ID of the connection used to sync this receipt
	SourceConnectionID *string `json:"source_connection_id,omitempty"`
	// Original file name
	FileName string `json:"file_name,omitempty"`
	// Storage path for the receipt file
	FilePath *string `json:"file_path,omitempty"`
	// MIME type of the receipt file
	MimeType string `json:"mime_type,omitempty"`
	// Size of the file in bytes
	FileSize int64 `json:"file_size,omitempty"`
	// Storage bucket name
	StorageBucket *string `json:"storage_bucket,omitempty"`
	// Storage key/path within bucket
	StorageKey *string `json:"storage_key,omitempty"`
	// Path to thumbnail image
	ThumbnailPath *string `json:"thumbnail_path,omitempty"`
	// Processing status of the receipt
	Status receipt.Status `json:"status,omitempty"`
	// Whether OCR processing has been completed
	OcrCompleted bool `json:"ocr_completed,omitempty"`
	// Extracted text from OCR
	OcrText *string `json:"ocr_text,omitempty"`
	// OCR confidence score (0-1)
	OcrConfidence *float64 `json:"ocr_confidence,omitempty"`
	// Extracted or user-provided merchant name
	MerchantName *string `json:"merchant_name,omitempty"`
	// Merchant address if available
	MerchantAddress *string `json:"merchant_address,omitempty"`
	// Date on the receipt
	ReceiptDate *time.Time `json:"receipt_date,omitempty"`
	// Total amount on the receipt
	TotalAmount *float64 `json:"total_amount,omitempty"`
	// Tax amount if extracted
	TaxAmount *float64 `json:"tax_amount,omitempty"`
	// Subtotal before tax
	SubtotalAmount *float64 `json:"subtotal_amount,omitempty"`
	// Currency code (ISO 4217)
	Currency string `json:"currency,omitempty"`
	// Payment method used
	PaymentMethod *string `json:"payment_method,omitempty"`
	// Receipt/transaction number from merchant
	ReceiptNumber *string `json:"receipt_number,omitempty"`
	// Category tags for the receipt
	CategoryTags []string `json:"category_tags,omitempty"`
	// Additional extracted data as JSON
	ExtractedData map[string]interface{} `json:"extracted_data,omitempty"`
	// Additional metadata
	Metadata map[string]interface{} `json:"metadata,omitempty"`
	// User notes about the receipt
	Notes *string `json:"notes,omitempty"`
	// ID from legacy system for migration tracking
	LegacyID *string `json:"legacy_id,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// When the receipt was processed
	ProcessedAt *time.Time `json:"processed_at,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the ReceiptQuery when eager-loading is set.
	Edges        ReceiptEdges `json:"edges"`
	selectValues sql.SelectValues
}

// ReceiptEdges holds the relations/edges for other nodes in the graph.
type ReceiptEdges struct {
	// Transactions associated with this receipt
	Transactions []*Transaction `json:"transactions,omitempty"`
	// Line items on this receipt
	LineItems []*LineItem `json:"line_items,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [2]bool
}

// TransactionsOrErr returns the Transactions value or an error if the edge
// was not loaded in eager-loading.
func (e ReceiptEdges) TransactionsOrErr() ([]*Transaction, error) {
	if e.loadedTypes[0] {
		return e.Transactions, nil
	}
	return nil, &NotLoadedError{edge: "transactions"}
}

// LineItemsOrErr returns the LineItems value or an error if the edge
// was not loaded in eager-loading.
func (e ReceiptEdges) LineItemsOrErr() ([]*LineItem, error) {
	if e.loadedTypes[1] {
		return e.LineItems, nil
	}
	return nil, &NotLoadedError{edge: "line_items"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Receipt) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case receipt.FieldCategoryTags, receipt.FieldExtractedData, receipt.FieldMetadata:
			values[i] = new([]byte)
		case receipt.FieldOcrCompleted:
			values[i] = new(sql.NullBool)
		case receipt.FieldOcrConfidence, receipt.FieldTotalAmount, receipt.FieldTaxAmount, receipt.FieldSubtotalAmount:
			values[i] = new(sql.NullFloat64)
		case receipt.FieldFileSize:
			values[i] = new(sql.NullInt64)
		case receipt.FieldID, receipt.FieldUserID, receipt.FieldSourceType, receipt.FieldSourceID, receipt.FieldSourceConnectionID, receipt.FieldFileName, receipt.FieldFilePath, receipt.FieldMimeType, receipt.FieldStorageBucket, receipt.FieldStorageKey, receipt.FieldThumbnailPath, receipt.FieldStatus, receipt.FieldOcrText, receipt.FieldMerchantName, receipt.FieldMerchantAddress, receipt.FieldCurrency, receipt.FieldPaymentMethod, receipt.FieldReceiptNumber, receipt.FieldNotes, receipt.FieldLegacyID:
			values[i] = new(sql.NullString)
		case receipt.FieldReceiptDate, receipt.FieldCreatedAt, receipt.FieldUpdatedAt, receipt.FieldProcessedAt:
			values[i] = new(sql.NullTime)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Receipt fields.
func (_m *Receipt) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case receipt.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				_m.ID = value.String
			}
		case receipt.FieldUserID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field user_id", values[i])
			} else if value.Valid {
				_m.UserID = value.String
			}
		case receipt.FieldSourceType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field source_type", values[i])
			} else if value.Valid {
				_m.SourceType = receipt.SourceType(value.String)
			}
		case receipt.FieldSourceID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field source_id", values[i])
			} else if value.Valid {
				_m.SourceID = new(string)
				*_m.SourceID = value.String
			}
		case receipt.FieldSourceConnectionID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field source_connection_id", values[i])
			} else if value.Valid {
				_m.SourceConnectionID = new(string)
				*_m.SourceConnectionID = value.String
			}
		case receipt.FieldFileName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field file_name", values[i])
			} else if value.Valid {
				_m.FileName = value.String
			}
		case receipt.FieldFilePath:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field file_path", values[i])
			} else if value.Valid {
				_m.FilePath = new(string)
				*_m.FilePath = value.String
			}
		case receipt.FieldMimeType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field mime_type", values[i])
			} else if value.Valid {
				_m.MimeType = value.String
			}
		case receipt.FieldFileSize:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field file_size", values[i])
			} else if value.Valid {
				_m.FileSize = value.Int64
			}
		case receipt.FieldStorageBucket:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field storage_bucket", values[i])
			} else if value.Valid {
				_m.StorageBucket = new(string)
				*_m.StorageBucket = value.String
			}
		case receipt.FieldStorageKey:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field storage_key", values[i])
			} else if value.Valid {
				_m.StorageKey = new(string)
				*_m.StorageKey = value.String
			}
		case receipt.FieldThumbnailPath:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field thumbnail_path", values[i])
			} else if value.Valid {
				_m.ThumbnailPath = new(string)
				*_m.ThumbnailPath = value.String
			}
		case receipt.FieldStatus:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field status", values[i])
			} else if value.Valid {
				_m.Status = receipt.Status(value.String)
			}
		case receipt.FieldOcrCompleted:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field ocr_completed", values[i])
			} else if value.Valid {
				_m.OcrCompleted = value.Bool
			}
		case receipt.FieldOcrText:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field ocr_text", values[i])
			} else if value.Valid {
				_m.OcrText = new(string)
				*_m.OcrText = value.String
			}
		case receipt.FieldOcrConfidence:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field ocr_confidence", values[i])
			} else if value.Valid {
				_m.OcrConfidence = new(float64)
				*_m.OcrConfidence = value.Float64
			}
		case receipt.FieldMerchantName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field merchant_name", values[i])
			} else if value.Valid {
				_m.MerchantName = new(string)
				*_m.MerchantName = value.String
			}
		case receipt.FieldMerchantAddress:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field merchant_address", values[i])
			} else if value.Valid {
				_m.MerchantAddress = new(string)
				*_m.MerchantAddress = value.String
			}
		case receipt.FieldReceiptDate:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field receipt_date", values[i])
			} else if value.Valid {
				_m.ReceiptDate = new(time.Time)
				*_m.ReceiptDate = value.Time
			}
		case receipt.FieldTotalAmount:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field total_amount", values[i])
			} else if value.Valid {
				_m.TotalAmount = new(float64)
				*_m.TotalAmount = value.Float64
			}
		case receipt.FieldTaxAmount:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field tax_amount", values[i])
			} else if value.Valid {
				_m.TaxAmount = new(float64)
				*_m.TaxAmount = value.Float64
			}
		case receipt.FieldSubtotalAmount:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field subtotal_amount", values[i])
			} else if value.Valid {
				_m.SubtotalAmount = new(float64)
				*_m.SubtotalAmount = value.Float64
			}
		case receipt.FieldCurrency:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field currency", values[i])
			} else if value.Valid {
				_m.Currency = value.String
			}
		case receipt.FieldPaymentMethod:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field payment_method", values[i])
			} else if value.Valid {
				_m.PaymentMethod = new(string)
				*_m.PaymentMethod = value.String
			}
		case receipt.FieldReceiptNumber:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field receipt_number", values[i])
			} else if value.Valid {
				_m.ReceiptNumber = new(string)
				*_m.ReceiptNumber = value.String
			}
		case receipt.FieldCategoryTags:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field category_tags", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &_m.CategoryTags); err != nil {
					return fmt.Errorf("unmarshal field category_tags: %w", err)
				}
			}
		case receipt.FieldExtractedData:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field extracted_data", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &_m.ExtractedData); err != nil {
					return fmt.Errorf("unmarshal field extracted_data: %w", err)
				}
			}
		case receipt.FieldMetadata:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field metadata", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &_m.Metadata); err != nil {
					return fmt.Errorf("unmarshal field metadata: %w", err)
				}
			}
		case receipt.FieldNotes:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field notes", values[i])
			} else if value.Valid {
				_m.Notes = new(string)
				*_m.Notes = value.String
			}
		case receipt.FieldLegacyID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field legacy_id", values[i])
			} else if value.Valid {
				_m.LegacyID = new(string)
				*_m.LegacyID = value.String
			}
		case receipt.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				_m.CreatedAt = value.Time
			}
		case receipt.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				_m.UpdatedAt = value.Time
			}
		case receipt.FieldProcessedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field processed_at", values[i])
			} else if value.Valid {
				_m.ProcessedAt = new(time.Time)
				*_m.ProcessedAt = value.Time
			}
		default:
			_m.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Receipt.
// This includes values selected through modifiers, order, etc.
func (_m *Receipt) Value(name string) (ent.Value, error) {
	return _m.selectValues.Get(name)
}

// QueryTransactions queries the "transactions" edge of the Receipt entity.
func (_m *Receipt) QueryTransactions() *TransactionQuery {
	return NewReceiptClient(_m.config).QueryTransactions(_m)
}

// QueryLineItems queries the "line_items" edge of the Receipt entity.
func (_m *Receipt) QueryLineItems() *LineItemQuery {
	return NewReceiptClient(_m.config).QueryLineItems(_m)
}

// Update returns a builder for updating this Receipt.
// Note that you need to call Receipt.Unwrap() before calling this method if this Receipt
// was returned from a transaction, and the transaction was committed or rolled back.
func (_m *Receipt) Update() *ReceiptUpdateOne {
	return NewReceiptClient(_m.config).UpdateOne(_m)
}

// Unwrap unwraps the Receipt entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (_m *Receipt) Unwrap() *Receipt {
	_tx, ok := _m.config.driver.(*txDriver)
	if !ok {
		panic("ent: Receipt is not a transactional entity")
	}
	_m.config.driver = _tx.drv
	return _m
}

// String implements the fmt.Stringer.
func (_m *Receipt) String() string {
	var builder strings.Builder
	builder.WriteString("Receipt(")
	builder.WriteString(fmt.Sprintf("id=%v, ", _m.ID))
	builder.WriteString("user_id=")
	builder.WriteString(_m.UserID)
	builder.WriteString(", ")
	builder.WriteString("source_type=")
	builder.WriteString(fmt.Sprintf("%v", _m.SourceType))
	builder.WriteString(", ")
	if v := _m.SourceID; v != nil {
		builder.WriteString("source_id=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := _m.SourceConnectionID; v != nil {
		builder.WriteString("source_connection_id=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("file_name=")
	builder.WriteString(_m.FileName)
	builder.WriteString(", ")
	if v := _m.FilePath; v != nil {
		builder.WriteString("file_path=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("mime_type=")
	builder.WriteString(_m.MimeType)
	builder.WriteString(", ")
	builder.WriteString("file_size=")
	builder.WriteString(fmt.Sprintf("%v", _m.FileSize))
	builder.WriteString(", ")
	if v := _m.StorageBucket; v != nil {
		builder.WriteString("storage_bucket=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := _m.StorageKey; v != nil {
		builder.WriteString("storage_key=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := _m.ThumbnailPath; v != nil {
		builder.WriteString("thumbnail_path=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("status=")
	builder.WriteString(fmt.Sprintf("%v", _m.Status))
	builder.WriteString(", ")
	builder.WriteString("ocr_completed=")
	builder.WriteString(fmt.Sprintf("%v", _m.OcrCompleted))
	builder.WriteString(", ")
	if v := _m.OcrText; v != nil {
		builder.WriteString("ocr_text=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := _m.OcrConfidence; v != nil {
		builder.WriteString("ocr_confidence=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := _m.MerchantName; v != nil {
		builder.WriteString("merchant_name=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := _m.MerchantAddress; v != nil {
		builder.WriteString("merchant_address=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := _m.ReceiptDate; v != nil {
		builder.WriteString("receipt_date=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := _m.TotalAmount; v != nil {
		builder.WriteString("total_amount=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := _m.TaxAmount; v != nil {
		builder.WriteString("tax_amount=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := _m.SubtotalAmount; v != nil {
		builder.WriteString("subtotal_amount=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	builder.WriteString("currency=")
	builder.WriteString(_m.Currency)
	builder.WriteString(", ")
	if v := _m.PaymentMethod; v != nil {
		builder.WriteString("payment_method=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := _m.ReceiptNumber; v != nil {
		builder.WriteString("receipt_number=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("category_tags=")
	builder.WriteString(fmt.Sprintf("%v", _m.CategoryTags))
	builder.WriteString(", ")
	builder.WriteString("extracted_data=")
	builder.WriteString(fmt.Sprintf("%v", _m.ExtractedData))
	builder.WriteString(", ")
	builder.WriteString("metadata=")
	builder.WriteString(fmt.Sprintf("%v", _m.Metadata))
	builder.WriteString(", ")
	if v := _m.Notes; v != nil {
		builder.WriteString("notes=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := _m.LegacyID; v != nil {
		builder.WriteString("legacy_id=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("created_at=")
	builder.WriteString(_m.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(_m.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	if v := _m.ProcessedAt; v != nil {
		builder.WriteString("processed_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteByte(')')
	return builder.String()
}

// Receipts is a parsable slice of Receipt.
type Receipts []*Receipt

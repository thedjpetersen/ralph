// Code generated by ent, DO NOT EDIT.

package ent

import (
	"clockzen-next/internal/ent/emailconnection"
	"clockzen-next/internal/ent/emaillabel"
	"clockzen-next/internal/ent/emailsync"
	"clockzen-next/internal/ent/googledriveconnection"
	"clockzen-next/internal/ent/googledrivefolder"
	"clockzen-next/internal/ent/googledrivesync"
	"clockzen-next/internal/ent/lineitem"
	"clockzen-next/internal/ent/predicate"
	"clockzen-next/internal/ent/receipt"
	"clockzen-next/internal/ent/transaction"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeEmailConnection       = "EmailConnection"
	TypeEmailLabel            = "EmailLabel"
	TypeEmailSync             = "EmailSync"
	TypeGoogleDriveConnection = "GoogleDriveConnection"
	TypeGoogleDriveFolder     = "GoogleDriveFolder"
	TypeGoogleDriveSync       = "GoogleDriveSync"
	TypeLineItem              = "LineItem"
	TypeReceipt               = "Receipt"
	TypeTransaction           = "Transaction"
)

// EmailConnectionMutation represents an operation that mutates the EmailConnection nodes in the graph.
type EmailConnectionMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	user_id             *string
	provider_account_id *string
	email               *string
	provider            *emailconnection.Provider
	access_token        *string
	refresh_token       *string
	token_expiry        *time.Time
	status              *emailconnection.Status
	created_at          *time.Time
	updated_at          *time.Time
	last_sync_at        *time.Time
	clearedFields       map[string]struct{}
	labels              map[string]struct{}
	removedlabels       map[string]struct{}
	clearedlabels       bool
	syncs               map[string]struct{}
	removedsyncs        map[string]struct{}
	clearedsyncs        bool
	done                bool
	oldValue            func(context.Context) (*EmailConnection, error)
	predicates          []predicate.EmailConnection
}

var _ ent.Mutation = (*EmailConnectionMutation)(nil)

// emailconnectionOption allows management of the mutation configuration using functional options.
type emailconnectionOption func(*EmailConnectionMutation)

// newEmailConnectionMutation creates new mutation for the EmailConnection entity.
func newEmailConnectionMutation(c config, op Op, opts ...emailconnectionOption) *EmailConnectionMutation {
	m := &EmailConnectionMutation{
		config:        c,
		op:            op,
		typ:           TypeEmailConnection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailConnectionID sets the ID field of the mutation.
func withEmailConnectionID(id string) emailconnectionOption {
	return func(m *EmailConnectionMutation) {
		var (
			err   error
			once  sync.Once
			value *EmailConnection
		)
		m.oldValue = func(ctx context.Context) (*EmailConnection, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmailConnection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmailConnection sets the old EmailConnection of the mutation.
func withEmailConnection(node *EmailConnection) emailconnectionOption {
	return func(m *EmailConnectionMutation) {
		m.oldValue = func(context.Context) (*EmailConnection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailConnectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailConnectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EmailConnection entities.
func (m *EmailConnectionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailConnectionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailConnectionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmailConnection.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *EmailConnectionMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *EmailConnectionMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the EmailConnection entity.
// If the EmailConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailConnectionMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *EmailConnectionMutation) ResetUserID() {
	m.user_id = nil
}

// SetProviderAccountID sets the "provider_account_id" field.
func (m *EmailConnectionMutation) SetProviderAccountID(s string) {
	m.provider_account_id = &s
}

// ProviderAccountID returns the value of the "provider_account_id" field in the mutation.
func (m *EmailConnectionMutation) ProviderAccountID() (r string, exists bool) {
	v := m.provider_account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderAccountID returns the old "provider_account_id" field's value of the EmailConnection entity.
// If the EmailConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailConnectionMutation) OldProviderAccountID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderAccountID: %w", err)
	}
	return oldValue.ProviderAccountID, nil
}

// ResetProviderAccountID resets all changes to the "provider_account_id" field.
func (m *EmailConnectionMutation) ResetProviderAccountID() {
	m.provider_account_id = nil
}

// SetEmail sets the "email" field.
func (m *EmailConnectionMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *EmailConnectionMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the EmailConnection entity.
// If the EmailConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailConnectionMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *EmailConnectionMutation) ResetEmail() {
	m.email = nil
}

// SetProvider sets the "provider" field.
func (m *EmailConnectionMutation) SetProvider(e emailconnection.Provider) {
	m.provider = &e
}

// Provider returns the value of the "provider" field in the mutation.
func (m *EmailConnectionMutation) Provider() (r emailconnection.Provider, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the EmailConnection entity.
// If the EmailConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailConnectionMutation) OldProvider(ctx context.Context) (v emailconnection.Provider, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ResetProvider resets all changes to the "provider" field.
func (m *EmailConnectionMutation) ResetProvider() {
	m.provider = nil
}

// SetAccessToken sets the "access_token" field.
func (m *EmailConnectionMutation) SetAccessToken(s string) {
	m.access_token = &s
}

// AccessToken returns the value of the "access_token" field in the mutation.
func (m *EmailConnectionMutation) AccessToken() (r string, exists bool) {
	v := m.access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessToken returns the old "access_token" field's value of the EmailConnection entity.
// If the EmailConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailConnectionMutation) OldAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessToken: %w", err)
	}
	return oldValue.AccessToken, nil
}

// ResetAccessToken resets all changes to the "access_token" field.
func (m *EmailConnectionMutation) ResetAccessToken() {
	m.access_token = nil
}

// SetRefreshToken sets the "refresh_token" field.
func (m *EmailConnectionMutation) SetRefreshToken(s string) {
	m.refresh_token = &s
}

// RefreshToken returns the value of the "refresh_token" field in the mutation.
func (m *EmailConnectionMutation) RefreshToken() (r string, exists bool) {
	v := m.refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshToken returns the old "refresh_token" field's value of the EmailConnection entity.
// If the EmailConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailConnectionMutation) OldRefreshToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshToken: %w", err)
	}
	return oldValue.RefreshToken, nil
}

// ResetRefreshToken resets all changes to the "refresh_token" field.
func (m *EmailConnectionMutation) ResetRefreshToken() {
	m.refresh_token = nil
}

// SetTokenExpiry sets the "token_expiry" field.
func (m *EmailConnectionMutation) SetTokenExpiry(t time.Time) {
	m.token_expiry = &t
}

// TokenExpiry returns the value of the "token_expiry" field in the mutation.
func (m *EmailConnectionMutation) TokenExpiry() (r time.Time, exists bool) {
	v := m.token_expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenExpiry returns the old "token_expiry" field's value of the EmailConnection entity.
// If the EmailConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailConnectionMutation) OldTokenExpiry(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenExpiry: %w", err)
	}
	return oldValue.TokenExpiry, nil
}

// ResetTokenExpiry resets all changes to the "token_expiry" field.
func (m *EmailConnectionMutation) ResetTokenExpiry() {
	m.token_expiry = nil
}

// SetStatus sets the "status" field.
func (m *EmailConnectionMutation) SetStatus(e emailconnection.Status) {
	m.status = &e
}

// Status returns the value of the "status" field in the mutation.
func (m *EmailConnectionMutation) Status() (r emailconnection.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the EmailConnection entity.
// If the EmailConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailConnectionMutation) OldStatus(ctx context.Context) (v emailconnection.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EmailConnectionMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EmailConnectionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmailConnectionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EmailConnection entity.
// If the EmailConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailConnectionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmailConnectionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmailConnectionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmailConnectionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EmailConnection entity.
// If the EmailConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailConnectionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmailConnectionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLastSyncAt sets the "last_sync_at" field.
func (m *EmailConnectionMutation) SetLastSyncAt(t time.Time) {
	m.last_sync_at = &t
}

// LastSyncAt returns the value of the "last_sync_at" field in the mutation.
func (m *EmailConnectionMutation) LastSyncAt() (r time.Time, exists bool) {
	v := m.last_sync_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSyncAt returns the old "last_sync_at" field's value of the EmailConnection entity.
// If the EmailConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailConnectionMutation) OldLastSyncAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSyncAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSyncAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSyncAt: %w", err)
	}
	return oldValue.LastSyncAt, nil
}

// ClearLastSyncAt clears the value of the "last_sync_at" field.
func (m *EmailConnectionMutation) ClearLastSyncAt() {
	m.last_sync_at = nil
	m.clearedFields[emailconnection.FieldLastSyncAt] = struct{}{}
}

// LastSyncAtCleared returns if the "last_sync_at" field was cleared in this mutation.
func (m *EmailConnectionMutation) LastSyncAtCleared() bool {
	_, ok := m.clearedFields[emailconnection.FieldLastSyncAt]
	return ok
}

// ResetLastSyncAt resets all changes to the "last_sync_at" field.
func (m *EmailConnectionMutation) ResetLastSyncAt() {
	m.last_sync_at = nil
	delete(m.clearedFields, emailconnection.FieldLastSyncAt)
}

// AddLabelIDs adds the "labels" edge to the EmailLabel entity by ids.
func (m *EmailConnectionMutation) AddLabelIDs(ids ...string) {
	if m.labels == nil {
		m.labels = make(map[string]struct{})
	}
	for i := range ids {
		m.labels[ids[i]] = struct{}{}
	}
}

// ClearLabels clears the "labels" edge to the EmailLabel entity.
func (m *EmailConnectionMutation) ClearLabels() {
	m.clearedlabels = true
}

// LabelsCleared reports if the "labels" edge to the EmailLabel entity was cleared.
func (m *EmailConnectionMutation) LabelsCleared() bool {
	return m.clearedlabels
}

// RemoveLabelIDs removes the "labels" edge to the EmailLabel entity by IDs.
func (m *EmailConnectionMutation) RemoveLabelIDs(ids ...string) {
	if m.removedlabels == nil {
		m.removedlabels = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.labels, ids[i])
		m.removedlabels[ids[i]] = struct{}{}
	}
}

// RemovedLabels returns the removed IDs of the "labels" edge to the EmailLabel entity.
func (m *EmailConnectionMutation) RemovedLabelsIDs() (ids []string) {
	for id := range m.removedlabels {
		ids = append(ids, id)
	}
	return
}

// LabelsIDs returns the "labels" edge IDs in the mutation.
func (m *EmailConnectionMutation) LabelsIDs() (ids []string) {
	for id := range m.labels {
		ids = append(ids, id)
	}
	return
}

// ResetLabels resets all changes to the "labels" edge.
func (m *EmailConnectionMutation) ResetLabels() {
	m.labels = nil
	m.clearedlabels = false
	m.removedlabels = nil
}

// AddSyncIDs adds the "syncs" edge to the EmailSync entity by ids.
func (m *EmailConnectionMutation) AddSyncIDs(ids ...string) {
	if m.syncs == nil {
		m.syncs = make(map[string]struct{})
	}
	for i := range ids {
		m.syncs[ids[i]] = struct{}{}
	}
}

// ClearSyncs clears the "syncs" edge to the EmailSync entity.
func (m *EmailConnectionMutation) ClearSyncs() {
	m.clearedsyncs = true
}

// SyncsCleared reports if the "syncs" edge to the EmailSync entity was cleared.
func (m *EmailConnectionMutation) SyncsCleared() bool {
	return m.clearedsyncs
}

// RemoveSyncIDs removes the "syncs" edge to the EmailSync entity by IDs.
func (m *EmailConnectionMutation) RemoveSyncIDs(ids ...string) {
	if m.removedsyncs == nil {
		m.removedsyncs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.syncs, ids[i])
		m.removedsyncs[ids[i]] = struct{}{}
	}
}

// RemovedSyncs returns the removed IDs of the "syncs" edge to the EmailSync entity.
func (m *EmailConnectionMutation) RemovedSyncsIDs() (ids []string) {
	for id := range m.removedsyncs {
		ids = append(ids, id)
	}
	return
}

// SyncsIDs returns the "syncs" edge IDs in the mutation.
func (m *EmailConnectionMutation) SyncsIDs() (ids []string) {
	for id := range m.syncs {
		ids = append(ids, id)
	}
	return
}

// ResetSyncs resets all changes to the "syncs" edge.
func (m *EmailConnectionMutation) ResetSyncs() {
	m.syncs = nil
	m.clearedsyncs = false
	m.removedsyncs = nil
}

// Where appends a list predicates to the EmailConnectionMutation builder.
func (m *EmailConnectionMutation) Where(ps ...predicate.EmailConnection) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailConnectionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailConnectionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmailConnection, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailConnectionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailConnectionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmailConnection).
func (m *EmailConnectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailConnectionMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.user_id != nil {
		fields = append(fields, emailconnection.FieldUserID)
	}
	if m.provider_account_id != nil {
		fields = append(fields, emailconnection.FieldProviderAccountID)
	}
	if m.email != nil {
		fields = append(fields, emailconnection.FieldEmail)
	}
	if m.provider != nil {
		fields = append(fields, emailconnection.FieldProvider)
	}
	if m.access_token != nil {
		fields = append(fields, emailconnection.FieldAccessToken)
	}
	if m.refresh_token != nil {
		fields = append(fields, emailconnection.FieldRefreshToken)
	}
	if m.token_expiry != nil {
		fields = append(fields, emailconnection.FieldTokenExpiry)
	}
	if m.status != nil {
		fields = append(fields, emailconnection.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, emailconnection.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, emailconnection.FieldUpdatedAt)
	}
	if m.last_sync_at != nil {
		fields = append(fields, emailconnection.FieldLastSyncAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailConnectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emailconnection.FieldUserID:
		return m.UserID()
	case emailconnection.FieldProviderAccountID:
		return m.ProviderAccountID()
	case emailconnection.FieldEmail:
		return m.Email()
	case emailconnection.FieldProvider:
		return m.Provider()
	case emailconnection.FieldAccessToken:
		return m.AccessToken()
	case emailconnection.FieldRefreshToken:
		return m.RefreshToken()
	case emailconnection.FieldTokenExpiry:
		return m.TokenExpiry()
	case emailconnection.FieldStatus:
		return m.Status()
	case emailconnection.FieldCreatedAt:
		return m.CreatedAt()
	case emailconnection.FieldUpdatedAt:
		return m.UpdatedAt()
	case emailconnection.FieldLastSyncAt:
		return m.LastSyncAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailConnectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emailconnection.FieldUserID:
		return m.OldUserID(ctx)
	case emailconnection.FieldProviderAccountID:
		return m.OldProviderAccountID(ctx)
	case emailconnection.FieldEmail:
		return m.OldEmail(ctx)
	case emailconnection.FieldProvider:
		return m.OldProvider(ctx)
	case emailconnection.FieldAccessToken:
		return m.OldAccessToken(ctx)
	case emailconnection.FieldRefreshToken:
		return m.OldRefreshToken(ctx)
	case emailconnection.FieldTokenExpiry:
		return m.OldTokenExpiry(ctx)
	case emailconnection.FieldStatus:
		return m.OldStatus(ctx)
	case emailconnection.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case emailconnection.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case emailconnection.FieldLastSyncAt:
		return m.OldLastSyncAt(ctx)
	}
	return nil, fmt.Errorf("unknown EmailConnection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailConnectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emailconnection.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case emailconnection.FieldProviderAccountID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderAccountID(v)
		return nil
	case emailconnection.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case emailconnection.FieldProvider:
		v, ok := value.(emailconnection.Provider)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case emailconnection.FieldAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessToken(v)
		return nil
	case emailconnection.FieldRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshToken(v)
		return nil
	case emailconnection.FieldTokenExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenExpiry(v)
		return nil
	case emailconnection.FieldStatus:
		v, ok := value.(emailconnection.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case emailconnection.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case emailconnection.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case emailconnection.FieldLastSyncAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSyncAt(v)
		return nil
	}
	return fmt.Errorf("unknown EmailConnection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailConnectionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailConnectionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailConnectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EmailConnection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailConnectionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(emailconnection.FieldLastSyncAt) {
		fields = append(fields, emailconnection.FieldLastSyncAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailConnectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailConnectionMutation) ClearField(name string) error {
	switch name {
	case emailconnection.FieldLastSyncAt:
		m.ClearLastSyncAt()
		return nil
	}
	return fmt.Errorf("unknown EmailConnection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailConnectionMutation) ResetField(name string) error {
	switch name {
	case emailconnection.FieldUserID:
		m.ResetUserID()
		return nil
	case emailconnection.FieldProviderAccountID:
		m.ResetProviderAccountID()
		return nil
	case emailconnection.FieldEmail:
		m.ResetEmail()
		return nil
	case emailconnection.FieldProvider:
		m.ResetProvider()
		return nil
	case emailconnection.FieldAccessToken:
		m.ResetAccessToken()
		return nil
	case emailconnection.FieldRefreshToken:
		m.ResetRefreshToken()
		return nil
	case emailconnection.FieldTokenExpiry:
		m.ResetTokenExpiry()
		return nil
	case emailconnection.FieldStatus:
		m.ResetStatus()
		return nil
	case emailconnection.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case emailconnection.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case emailconnection.FieldLastSyncAt:
		m.ResetLastSyncAt()
		return nil
	}
	return fmt.Errorf("unknown EmailConnection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailConnectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.labels != nil {
		edges = append(edges, emailconnection.EdgeLabels)
	}
	if m.syncs != nil {
		edges = append(edges, emailconnection.EdgeSyncs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailConnectionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case emailconnection.EdgeLabels:
		ids := make([]ent.Value, 0, len(m.labels))
		for id := range m.labels {
			ids = append(ids, id)
		}
		return ids
	case emailconnection.EdgeSyncs:
		ids := make([]ent.Value, 0, len(m.syncs))
		for id := range m.syncs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailConnectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedlabels != nil {
		edges = append(edges, emailconnection.EdgeLabels)
	}
	if m.removedsyncs != nil {
		edges = append(edges, emailconnection.EdgeSyncs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailConnectionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case emailconnection.EdgeLabels:
		ids := make([]ent.Value, 0, len(m.removedlabels))
		for id := range m.removedlabels {
			ids = append(ids, id)
		}
		return ids
	case emailconnection.EdgeSyncs:
		ids := make([]ent.Value, 0, len(m.removedsyncs))
		for id := range m.removedsyncs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailConnectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedlabels {
		edges = append(edges, emailconnection.EdgeLabels)
	}
	if m.clearedsyncs {
		edges = append(edges, emailconnection.EdgeSyncs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailConnectionMutation) EdgeCleared(name string) bool {
	switch name {
	case emailconnection.EdgeLabels:
		return m.clearedlabels
	case emailconnection.EdgeSyncs:
		return m.clearedsyncs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailConnectionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown EmailConnection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailConnectionMutation) ResetEdge(name string) error {
	switch name {
	case emailconnection.EdgeLabels:
		m.ResetLabels()
		return nil
	case emailconnection.EdgeSyncs:
		m.ResetSyncs()
		return nil
	}
	return fmt.Errorf("unknown EmailConnection edge %s", name)
}

// EmailLabelMutation represents an operation that mutates the EmailLabel nodes in the graph.
type EmailLabelMutation struct {
	config
	op                Op
	typ               string
	id                *string
	provider_label_id *string
	name              *string
	display_name      *string
	label_type        *emaillabel.LabelType
	parent_label_id   *string
	sync_enabled      *bool
	message_count     *int64
	addmessage_count  *int64
	unread_count      *int64
	addunread_count   *int64
	color             *string
	created_at        *time.Time
	updated_at        *time.Time
	last_scanned_at   *time.Time
	clearedFields     map[string]struct{}
	connection        *string
	clearedconnection bool
	done              bool
	oldValue          func(context.Context) (*EmailLabel, error)
	predicates        []predicate.EmailLabel
}

var _ ent.Mutation = (*EmailLabelMutation)(nil)

// emaillabelOption allows management of the mutation configuration using functional options.
type emaillabelOption func(*EmailLabelMutation)

// newEmailLabelMutation creates new mutation for the EmailLabel entity.
func newEmailLabelMutation(c config, op Op, opts ...emaillabelOption) *EmailLabelMutation {
	m := &EmailLabelMutation{
		config:        c,
		op:            op,
		typ:           TypeEmailLabel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailLabelID sets the ID field of the mutation.
func withEmailLabelID(id string) emaillabelOption {
	return func(m *EmailLabelMutation) {
		var (
			err   error
			once  sync.Once
			value *EmailLabel
		)
		m.oldValue = func(ctx context.Context) (*EmailLabel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmailLabel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmailLabel sets the old EmailLabel of the mutation.
func withEmailLabel(node *EmailLabel) emaillabelOption {
	return func(m *EmailLabelMutation) {
		m.oldValue = func(context.Context) (*EmailLabel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailLabelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailLabelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EmailLabel entities.
func (m *EmailLabelMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailLabelMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailLabelMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmailLabel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetConnectionID sets the "connection_id" field.
func (m *EmailLabelMutation) SetConnectionID(s string) {
	m.connection = &s
}

// ConnectionID returns the value of the "connection_id" field in the mutation.
func (m *EmailLabelMutation) ConnectionID() (r string, exists bool) {
	v := m.connection
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectionID returns the old "connection_id" field's value of the EmailLabel entity.
// If the EmailLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLabelMutation) OldConnectionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectionID: %w", err)
	}
	return oldValue.ConnectionID, nil
}

// ResetConnectionID resets all changes to the "connection_id" field.
func (m *EmailLabelMutation) ResetConnectionID() {
	m.connection = nil
}

// SetProviderLabelID sets the "provider_label_id" field.
func (m *EmailLabelMutation) SetProviderLabelID(s string) {
	m.provider_label_id = &s
}

// ProviderLabelID returns the value of the "provider_label_id" field in the mutation.
func (m *EmailLabelMutation) ProviderLabelID() (r string, exists bool) {
	v := m.provider_label_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderLabelID returns the old "provider_label_id" field's value of the EmailLabel entity.
// If the EmailLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLabelMutation) OldProviderLabelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderLabelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderLabelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderLabelID: %w", err)
	}
	return oldValue.ProviderLabelID, nil
}

// ResetProviderLabelID resets all changes to the "provider_label_id" field.
func (m *EmailLabelMutation) ResetProviderLabelID() {
	m.provider_label_id = nil
}

// SetName sets the "name" field.
func (m *EmailLabelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EmailLabelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EmailLabel entity.
// If the EmailLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLabelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EmailLabelMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *EmailLabelMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *EmailLabelMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the EmailLabel entity.
// If the EmailLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLabelMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *EmailLabelMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[emaillabel.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *EmailLabelMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[emaillabel.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *EmailLabelMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, emaillabel.FieldDisplayName)
}

// SetLabelType sets the "label_type" field.
func (m *EmailLabelMutation) SetLabelType(et emaillabel.LabelType) {
	m.label_type = &et
}

// LabelType returns the value of the "label_type" field in the mutation.
func (m *EmailLabelMutation) LabelType() (r emaillabel.LabelType, exists bool) {
	v := m.label_type
	if v == nil {
		return
	}
	return *v, true
}

// OldLabelType returns the old "label_type" field's value of the EmailLabel entity.
// If the EmailLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLabelMutation) OldLabelType(ctx context.Context) (v emaillabel.LabelType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabelType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabelType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabelType: %w", err)
	}
	return oldValue.LabelType, nil
}

// ResetLabelType resets all changes to the "label_type" field.
func (m *EmailLabelMutation) ResetLabelType() {
	m.label_type = nil
}

// SetParentLabelID sets the "parent_label_id" field.
func (m *EmailLabelMutation) SetParentLabelID(s string) {
	m.parent_label_id = &s
}

// ParentLabelID returns the value of the "parent_label_id" field in the mutation.
func (m *EmailLabelMutation) ParentLabelID() (r string, exists bool) {
	v := m.parent_label_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentLabelID returns the old "parent_label_id" field's value of the EmailLabel entity.
// If the EmailLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLabelMutation) OldParentLabelID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentLabelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentLabelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentLabelID: %w", err)
	}
	return oldValue.ParentLabelID, nil
}

// ClearParentLabelID clears the value of the "parent_label_id" field.
func (m *EmailLabelMutation) ClearParentLabelID() {
	m.parent_label_id = nil
	m.clearedFields[emaillabel.FieldParentLabelID] = struct{}{}
}

// ParentLabelIDCleared returns if the "parent_label_id" field was cleared in this mutation.
func (m *EmailLabelMutation) ParentLabelIDCleared() bool {
	_, ok := m.clearedFields[emaillabel.FieldParentLabelID]
	return ok
}

// ResetParentLabelID resets all changes to the "parent_label_id" field.
func (m *EmailLabelMutation) ResetParentLabelID() {
	m.parent_label_id = nil
	delete(m.clearedFields, emaillabel.FieldParentLabelID)
}

// SetSyncEnabled sets the "sync_enabled" field.
func (m *EmailLabelMutation) SetSyncEnabled(b bool) {
	m.sync_enabled = &b
}

// SyncEnabled returns the value of the "sync_enabled" field in the mutation.
func (m *EmailLabelMutation) SyncEnabled() (r bool, exists bool) {
	v := m.sync_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncEnabled returns the old "sync_enabled" field's value of the EmailLabel entity.
// If the EmailLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLabelMutation) OldSyncEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncEnabled: %w", err)
	}
	return oldValue.SyncEnabled, nil
}

// ResetSyncEnabled resets all changes to the "sync_enabled" field.
func (m *EmailLabelMutation) ResetSyncEnabled() {
	m.sync_enabled = nil
}

// SetMessageCount sets the "message_count" field.
func (m *EmailLabelMutation) SetMessageCount(i int64) {
	m.message_count = &i
	m.addmessage_count = nil
}

// MessageCount returns the value of the "message_count" field in the mutation.
func (m *EmailLabelMutation) MessageCount() (r int64, exists bool) {
	v := m.message_count
	if v == nil {
		return
	}
	return *v, true
}

// OldMessageCount returns the old "message_count" field's value of the EmailLabel entity.
// If the EmailLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLabelMutation) OldMessageCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessageCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessageCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessageCount: %w", err)
	}
	return oldValue.MessageCount, nil
}

// AddMessageCount adds i to the "message_count" field.
func (m *EmailLabelMutation) AddMessageCount(i int64) {
	if m.addmessage_count != nil {
		*m.addmessage_count += i
	} else {
		m.addmessage_count = &i
	}
}

// AddedMessageCount returns the value that was added to the "message_count" field in this mutation.
func (m *EmailLabelMutation) AddedMessageCount() (r int64, exists bool) {
	v := m.addmessage_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetMessageCount resets all changes to the "message_count" field.
func (m *EmailLabelMutation) ResetMessageCount() {
	m.message_count = nil
	m.addmessage_count = nil
}

// SetUnreadCount sets the "unread_count" field.
func (m *EmailLabelMutation) SetUnreadCount(i int64) {
	m.unread_count = &i
	m.addunread_count = nil
}

// UnreadCount returns the value of the "unread_count" field in the mutation.
func (m *EmailLabelMutation) UnreadCount() (r int64, exists bool) {
	v := m.unread_count
	if v == nil {
		return
	}
	return *v, true
}

// OldUnreadCount returns the old "unread_count" field's value of the EmailLabel entity.
// If the EmailLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLabelMutation) OldUnreadCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnreadCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnreadCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnreadCount: %w", err)
	}
	return oldValue.UnreadCount, nil
}

// AddUnreadCount adds i to the "unread_count" field.
func (m *EmailLabelMutation) AddUnreadCount(i int64) {
	if m.addunread_count != nil {
		*m.addunread_count += i
	} else {
		m.addunread_count = &i
	}
}

// AddedUnreadCount returns the value that was added to the "unread_count" field in this mutation.
func (m *EmailLabelMutation) AddedUnreadCount() (r int64, exists bool) {
	v := m.addunread_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnreadCount resets all changes to the "unread_count" field.
func (m *EmailLabelMutation) ResetUnreadCount() {
	m.unread_count = nil
	m.addunread_count = nil
}

// SetColor sets the "color" field.
func (m *EmailLabelMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *EmailLabelMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the EmailLabel entity.
// If the EmailLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLabelMutation) OldColor(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *EmailLabelMutation) ClearColor() {
	m.color = nil
	m.clearedFields[emaillabel.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *EmailLabelMutation) ColorCleared() bool {
	_, ok := m.clearedFields[emaillabel.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *EmailLabelMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, emaillabel.FieldColor)
}

// SetCreatedAt sets the "created_at" field.
func (m *EmailLabelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmailLabelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EmailLabel entity.
// If the EmailLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLabelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmailLabelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmailLabelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmailLabelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EmailLabel entity.
// If the EmailLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLabelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmailLabelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLastScannedAt sets the "last_scanned_at" field.
func (m *EmailLabelMutation) SetLastScannedAt(t time.Time) {
	m.last_scanned_at = &t
}

// LastScannedAt returns the value of the "last_scanned_at" field in the mutation.
func (m *EmailLabelMutation) LastScannedAt() (r time.Time, exists bool) {
	v := m.last_scanned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastScannedAt returns the old "last_scanned_at" field's value of the EmailLabel entity.
// If the EmailLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLabelMutation) OldLastScannedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastScannedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastScannedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastScannedAt: %w", err)
	}
	return oldValue.LastScannedAt, nil
}

// ClearLastScannedAt clears the value of the "last_scanned_at" field.
func (m *EmailLabelMutation) ClearLastScannedAt() {
	m.last_scanned_at = nil
	m.clearedFields[emaillabel.FieldLastScannedAt] = struct{}{}
}

// LastScannedAtCleared returns if the "last_scanned_at" field was cleared in this mutation.
func (m *EmailLabelMutation) LastScannedAtCleared() bool {
	_, ok := m.clearedFields[emaillabel.FieldLastScannedAt]
	return ok
}

// ResetLastScannedAt resets all changes to the "last_scanned_at" field.
func (m *EmailLabelMutation) ResetLastScannedAt() {
	m.last_scanned_at = nil
	delete(m.clearedFields, emaillabel.FieldLastScannedAt)
}

// ClearConnection clears the "connection" edge to the EmailConnection entity.
func (m *EmailLabelMutation) ClearConnection() {
	m.clearedconnection = true
	m.clearedFields[emaillabel.FieldConnectionID] = struct{}{}
}

// ConnectionCleared reports if the "connection" edge to the EmailConnection entity was cleared.
func (m *EmailLabelMutation) ConnectionCleared() bool {
	return m.clearedconnection
}

// ConnectionIDs returns the "connection" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectionID instead. It exists only for internal usage by the builders.
func (m *EmailLabelMutation) ConnectionIDs() (ids []string) {
	if id := m.connection; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnection resets all changes to the "connection" edge.
func (m *EmailLabelMutation) ResetConnection() {
	m.connection = nil
	m.clearedconnection = false
}

// Where appends a list predicates to the EmailLabelMutation builder.
func (m *EmailLabelMutation) Where(ps ...predicate.EmailLabel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailLabelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailLabelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmailLabel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailLabelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailLabelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmailLabel).
func (m *EmailLabelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailLabelMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.connection != nil {
		fields = append(fields, emaillabel.FieldConnectionID)
	}
	if m.provider_label_id != nil {
		fields = append(fields, emaillabel.FieldProviderLabelID)
	}
	if m.name != nil {
		fields = append(fields, emaillabel.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, emaillabel.FieldDisplayName)
	}
	if m.label_type != nil {
		fields = append(fields, emaillabel.FieldLabelType)
	}
	if m.parent_label_id != nil {
		fields = append(fields, emaillabel.FieldParentLabelID)
	}
	if m.sync_enabled != nil {
		fields = append(fields, emaillabel.FieldSyncEnabled)
	}
	if m.message_count != nil {
		fields = append(fields, emaillabel.FieldMessageCount)
	}
	if m.unread_count != nil {
		fields = append(fields, emaillabel.FieldUnreadCount)
	}
	if m.color != nil {
		fields = append(fields, emaillabel.FieldColor)
	}
	if m.created_at != nil {
		fields = append(fields, emaillabel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, emaillabel.FieldUpdatedAt)
	}
	if m.last_scanned_at != nil {
		fields = append(fields, emaillabel.FieldLastScannedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailLabelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emaillabel.FieldConnectionID:
		return m.ConnectionID()
	case emaillabel.FieldProviderLabelID:
		return m.ProviderLabelID()
	case emaillabel.FieldName:
		return m.Name()
	case emaillabel.FieldDisplayName:
		return m.DisplayName()
	case emaillabel.FieldLabelType:
		return m.LabelType()
	case emaillabel.FieldParentLabelID:
		return m.ParentLabelID()
	case emaillabel.FieldSyncEnabled:
		return m.SyncEnabled()
	case emaillabel.FieldMessageCount:
		return m.MessageCount()
	case emaillabel.FieldUnreadCount:
		return m.UnreadCount()
	case emaillabel.FieldColor:
		return m.Color()
	case emaillabel.FieldCreatedAt:
		return m.CreatedAt()
	case emaillabel.FieldUpdatedAt:
		return m.UpdatedAt()
	case emaillabel.FieldLastScannedAt:
		return m.LastScannedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailLabelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emaillabel.FieldConnectionID:
		return m.OldConnectionID(ctx)
	case emaillabel.FieldProviderLabelID:
		return m.OldProviderLabelID(ctx)
	case emaillabel.FieldName:
		return m.OldName(ctx)
	case emaillabel.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case emaillabel.FieldLabelType:
		return m.OldLabelType(ctx)
	case emaillabel.FieldParentLabelID:
		return m.OldParentLabelID(ctx)
	case emaillabel.FieldSyncEnabled:
		return m.OldSyncEnabled(ctx)
	case emaillabel.FieldMessageCount:
		return m.OldMessageCount(ctx)
	case emaillabel.FieldUnreadCount:
		return m.OldUnreadCount(ctx)
	case emaillabel.FieldColor:
		return m.OldColor(ctx)
	case emaillabel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case emaillabel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case emaillabel.FieldLastScannedAt:
		return m.OldLastScannedAt(ctx)
	}
	return nil, fmt.Errorf("unknown EmailLabel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailLabelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emaillabel.FieldConnectionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectionID(v)
		return nil
	case emaillabel.FieldProviderLabelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderLabelID(v)
		return nil
	case emaillabel.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case emaillabel.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case emaillabel.FieldLabelType:
		v, ok := value.(emaillabel.LabelType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabelType(v)
		return nil
	case emaillabel.FieldParentLabelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentLabelID(v)
		return nil
	case emaillabel.FieldSyncEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncEnabled(v)
		return nil
	case emaillabel.FieldMessageCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessageCount(v)
		return nil
	case emaillabel.FieldUnreadCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnreadCount(v)
		return nil
	case emaillabel.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case emaillabel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case emaillabel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case emaillabel.FieldLastScannedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastScannedAt(v)
		return nil
	}
	return fmt.Errorf("unknown EmailLabel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailLabelMutation) AddedFields() []string {
	var fields []string
	if m.addmessage_count != nil {
		fields = append(fields, emaillabel.FieldMessageCount)
	}
	if m.addunread_count != nil {
		fields = append(fields, emaillabel.FieldUnreadCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailLabelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case emaillabel.FieldMessageCount:
		return m.AddedMessageCount()
	case emaillabel.FieldUnreadCount:
		return m.AddedUnreadCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailLabelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case emaillabel.FieldMessageCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMessageCount(v)
		return nil
	case emaillabel.FieldUnreadCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnreadCount(v)
		return nil
	}
	return fmt.Errorf("unknown EmailLabel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailLabelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(emaillabel.FieldDisplayName) {
		fields = append(fields, emaillabel.FieldDisplayName)
	}
	if m.FieldCleared(emaillabel.FieldParentLabelID) {
		fields = append(fields, emaillabel.FieldParentLabelID)
	}
	if m.FieldCleared(emaillabel.FieldColor) {
		fields = append(fields, emaillabel.FieldColor)
	}
	if m.FieldCleared(emaillabel.FieldLastScannedAt) {
		fields = append(fields, emaillabel.FieldLastScannedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailLabelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailLabelMutation) ClearField(name string) error {
	switch name {
	case emaillabel.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case emaillabel.FieldParentLabelID:
		m.ClearParentLabelID()
		return nil
	case emaillabel.FieldColor:
		m.ClearColor()
		return nil
	case emaillabel.FieldLastScannedAt:
		m.ClearLastScannedAt()
		return nil
	}
	return fmt.Errorf("unknown EmailLabel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailLabelMutation) ResetField(name string) error {
	switch name {
	case emaillabel.FieldConnectionID:
		m.ResetConnectionID()
		return nil
	case emaillabel.FieldProviderLabelID:
		m.ResetProviderLabelID()
		return nil
	case emaillabel.FieldName:
		m.ResetName()
		return nil
	case emaillabel.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case emaillabel.FieldLabelType:
		m.ResetLabelType()
		return nil
	case emaillabel.FieldParentLabelID:
		m.ResetParentLabelID()
		return nil
	case emaillabel.FieldSyncEnabled:
		m.ResetSyncEnabled()
		return nil
	case emaillabel.FieldMessageCount:
		m.ResetMessageCount()
		return nil
	case emaillabel.FieldUnreadCount:
		m.ResetUnreadCount()
		return nil
	case emaillabel.FieldColor:
		m.ResetColor()
		return nil
	case emaillabel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case emaillabel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case emaillabel.FieldLastScannedAt:
		m.ResetLastScannedAt()
		return nil
	}
	return fmt.Errorf("unknown EmailLabel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailLabelMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.connection != nil {
		edges = append(edges, emaillabel.EdgeConnection)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailLabelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case emaillabel.EdgeConnection:
		if id := m.connection; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailLabelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailLabelMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailLabelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedconnection {
		edges = append(edges, emaillabel.EdgeConnection)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailLabelMutation) EdgeCleared(name string) bool {
	switch name {
	case emaillabel.EdgeConnection:
		return m.clearedconnection
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailLabelMutation) ClearEdge(name string) error {
	switch name {
	case emaillabel.EdgeConnection:
		m.ClearConnection()
		return nil
	}
	return fmt.Errorf("unknown EmailLabel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailLabelMutation) ResetEdge(name string) error {
	switch name {
	case emaillabel.EdgeConnection:
		m.ResetConnection()
		return nil
	}
	return fmt.Errorf("unknown EmailLabel edge %s", name)
}

// EmailSyncMutation represents an operation that mutates the EmailSync nodes in the graph.
type EmailSyncMutation struct {
	config
	op                        Op
	typ                       string
	id                        *string
	label_id                  *string
	sync_type                 *emailsync.SyncType
	status                    *emailsync.Status
	started_at                *time.Time
	completed_at              *time.Time
	messages_scanned          *int
	addmessages_scanned       *int
	messages_downloaded       *int
	addmessages_downloaded    *int
	messages_indexed          *int
	addmessages_indexed       *int
	messages_failed           *int
	addmessages_failed        *int
	attachments_downloaded    *int
	addattachments_downloaded *int
	bytes_transferred         *int64
	addbytes_transferred      *int64
	error_message             *string
	error_details             *map[string]interface{}
	history_id                *string
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	connection                *string
	clearedconnection         bool
	done                      bool
	oldValue                  func(context.Context) (*EmailSync, error)
	predicates                []predicate.EmailSync
}

var _ ent.Mutation = (*EmailSyncMutation)(nil)

// emailsyncOption allows management of the mutation configuration using functional options.
type emailsyncOption func(*EmailSyncMutation)

// newEmailSyncMutation creates new mutation for the EmailSync entity.
func newEmailSyncMutation(c config, op Op, opts ...emailsyncOption) *EmailSyncMutation {
	m := &EmailSyncMutation{
		config:        c,
		op:            op,
		typ:           TypeEmailSync,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailSyncID sets the ID field of the mutation.
func withEmailSyncID(id string) emailsyncOption {
	return func(m *EmailSyncMutation) {
		var (
			err   error
			once  sync.Once
			value *EmailSync
		)
		m.oldValue = func(ctx context.Context) (*EmailSync, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmailSync.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmailSync sets the old EmailSync of the mutation.
func withEmailSync(node *EmailSync) emailsyncOption {
	return func(m *EmailSyncMutation) {
		m.oldValue = func(context.Context) (*EmailSync, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailSyncMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailSyncMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EmailSync entities.
func (m *EmailSyncMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailSyncMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailSyncMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmailSync.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetConnectionID sets the "connection_id" field.
func (m *EmailSyncMutation) SetConnectionID(s string) {
	m.connection = &s
}

// ConnectionID returns the value of the "connection_id" field in the mutation.
func (m *EmailSyncMutation) ConnectionID() (r string, exists bool) {
	v := m.connection
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectionID returns the old "connection_id" field's value of the EmailSync entity.
// If the EmailSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSyncMutation) OldConnectionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectionID: %w", err)
	}
	return oldValue.ConnectionID, nil
}

// ResetConnectionID resets all changes to the "connection_id" field.
func (m *EmailSyncMutation) ResetConnectionID() {
	m.connection = nil
}

// SetLabelID sets the "label_id" field.
func (m *EmailSyncMutation) SetLabelID(s string) {
	m.label_id = &s
}

// LabelID returns the value of the "label_id" field in the mutation.
func (m *EmailSyncMutation) LabelID() (r string, exists bool) {
	v := m.label_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLabelID returns the old "label_id" field's value of the EmailSync entity.
// If the EmailSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSyncMutation) OldLabelID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabelID: %w", err)
	}
	return oldValue.LabelID, nil
}

// ClearLabelID clears the value of the "label_id" field.
func (m *EmailSyncMutation) ClearLabelID() {
	m.label_id = nil
	m.clearedFields[emailsync.FieldLabelID] = struct{}{}
}

// LabelIDCleared returns if the "label_id" field was cleared in this mutation.
func (m *EmailSyncMutation) LabelIDCleared() bool {
	_, ok := m.clearedFields[emailsync.FieldLabelID]
	return ok
}

// ResetLabelID resets all changes to the "label_id" field.
func (m *EmailSyncMutation) ResetLabelID() {
	m.label_id = nil
	delete(m.clearedFields, emailsync.FieldLabelID)
}

// SetSyncType sets the "sync_type" field.
func (m *EmailSyncMutation) SetSyncType(et emailsync.SyncType) {
	m.sync_type = &et
}

// SyncType returns the value of the "sync_type" field in the mutation.
func (m *EmailSyncMutation) SyncType() (r emailsync.SyncType, exists bool) {
	v := m.sync_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncType returns the old "sync_type" field's value of the EmailSync entity.
// If the EmailSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSyncMutation) OldSyncType(ctx context.Context) (v emailsync.SyncType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncType: %w", err)
	}
	return oldValue.SyncType, nil
}

// ResetSyncType resets all changes to the "sync_type" field.
func (m *EmailSyncMutation) ResetSyncType() {
	m.sync_type = nil
}

// SetStatus sets the "status" field.
func (m *EmailSyncMutation) SetStatus(e emailsync.Status) {
	m.status = &e
}

// Status returns the value of the "status" field in the mutation.
func (m *EmailSyncMutation) Status() (r emailsync.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the EmailSync entity.
// If the EmailSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSyncMutation) OldStatus(ctx context.Context) (v emailsync.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EmailSyncMutation) ResetStatus() {
	m.status = nil
}

// SetStartedAt sets the "started_at" field.
func (m *EmailSyncMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *EmailSyncMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the EmailSync entity.
// If the EmailSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSyncMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *EmailSyncMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[emailsync.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *EmailSyncMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[emailsync.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *EmailSyncMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, emailsync.FieldStartedAt)
}

// SetCompletedAt sets the "completed_at" field.
func (m *EmailSyncMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *EmailSyncMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the EmailSync entity.
// If the EmailSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSyncMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *EmailSyncMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[emailsync.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *EmailSyncMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[emailsync.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *EmailSyncMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, emailsync.FieldCompletedAt)
}

// SetMessagesScanned sets the "messages_scanned" field.
func (m *EmailSyncMutation) SetMessagesScanned(i int) {
	m.messages_scanned = &i
	m.addmessages_scanned = nil
}

// MessagesScanned returns the value of the "messages_scanned" field in the mutation.
func (m *EmailSyncMutation) MessagesScanned() (r int, exists bool) {
	v := m.messages_scanned
	if v == nil {
		return
	}
	return *v, true
}

// OldMessagesScanned returns the old "messages_scanned" field's value of the EmailSync entity.
// If the EmailSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSyncMutation) OldMessagesScanned(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessagesScanned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessagesScanned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessagesScanned: %w", err)
	}
	return oldValue.MessagesScanned, nil
}

// AddMessagesScanned adds i to the "messages_scanned" field.
func (m *EmailSyncMutation) AddMessagesScanned(i int) {
	if m.addmessages_scanned != nil {
		*m.addmessages_scanned += i
	} else {
		m.addmessages_scanned = &i
	}
}

// AddedMessagesScanned returns the value that was added to the "messages_scanned" field in this mutation.
func (m *EmailSyncMutation) AddedMessagesScanned() (r int, exists bool) {
	v := m.addmessages_scanned
	if v == nil {
		return
	}
	return *v, true
}

// ResetMessagesScanned resets all changes to the "messages_scanned" field.
func (m *EmailSyncMutation) ResetMessagesScanned() {
	m.messages_scanned = nil
	m.addmessages_scanned = nil
}

// SetMessagesDownloaded sets the "messages_downloaded" field.
func (m *EmailSyncMutation) SetMessagesDownloaded(i int) {
	m.messages_downloaded = &i
	m.addmessages_downloaded = nil
}

// MessagesDownloaded returns the value of the "messages_downloaded" field in the mutation.
func (m *EmailSyncMutation) MessagesDownloaded() (r int, exists bool) {
	v := m.messages_downloaded
	if v == nil {
		return
	}
	return *v, true
}

// OldMessagesDownloaded returns the old "messages_downloaded" field's value of the EmailSync entity.
// If the EmailSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSyncMutation) OldMessagesDownloaded(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessagesDownloaded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessagesDownloaded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessagesDownloaded: %w", err)
	}
	return oldValue.MessagesDownloaded, nil
}

// AddMessagesDownloaded adds i to the "messages_downloaded" field.
func (m *EmailSyncMutation) AddMessagesDownloaded(i int) {
	if m.addmessages_downloaded != nil {
		*m.addmessages_downloaded += i
	} else {
		m.addmessages_downloaded = &i
	}
}

// AddedMessagesDownloaded returns the value that was added to the "messages_downloaded" field in this mutation.
func (m *EmailSyncMutation) AddedMessagesDownloaded() (r int, exists bool) {
	v := m.addmessages_downloaded
	if v == nil {
		return
	}
	return *v, true
}

// ResetMessagesDownloaded resets all changes to the "messages_downloaded" field.
func (m *EmailSyncMutation) ResetMessagesDownloaded() {
	m.messages_downloaded = nil
	m.addmessages_downloaded = nil
}

// SetMessagesIndexed sets the "messages_indexed" field.
func (m *EmailSyncMutation) SetMessagesIndexed(i int) {
	m.messages_indexed = &i
	m.addmessages_indexed = nil
}

// MessagesIndexed returns the value of the "messages_indexed" field in the mutation.
func (m *EmailSyncMutation) MessagesIndexed() (r int, exists bool) {
	v := m.messages_indexed
	if v == nil {
		return
	}
	return *v, true
}

// OldMessagesIndexed returns the old "messages_indexed" field's value of the EmailSync entity.
// If the EmailSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSyncMutation) OldMessagesIndexed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessagesIndexed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessagesIndexed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessagesIndexed: %w", err)
	}
	return oldValue.MessagesIndexed, nil
}

// AddMessagesIndexed adds i to the "messages_indexed" field.
func (m *EmailSyncMutation) AddMessagesIndexed(i int) {
	if m.addmessages_indexed != nil {
		*m.addmessages_indexed += i
	} else {
		m.addmessages_indexed = &i
	}
}

// AddedMessagesIndexed returns the value that was added to the "messages_indexed" field in this mutation.
func (m *EmailSyncMutation) AddedMessagesIndexed() (r int, exists bool) {
	v := m.addmessages_indexed
	if v == nil {
		return
	}
	return *v, true
}

// ResetMessagesIndexed resets all changes to the "messages_indexed" field.
func (m *EmailSyncMutation) ResetMessagesIndexed() {
	m.messages_indexed = nil
	m.addmessages_indexed = nil
}

// SetMessagesFailed sets the "messages_failed" field.
func (m *EmailSyncMutation) SetMessagesFailed(i int) {
	m.messages_failed = &i
	m.addmessages_failed = nil
}

// MessagesFailed returns the value of the "messages_failed" field in the mutation.
func (m *EmailSyncMutation) MessagesFailed() (r int, exists bool) {
	v := m.messages_failed
	if v == nil {
		return
	}
	return *v, true
}

// OldMessagesFailed returns the old "messages_failed" field's value of the EmailSync entity.
// If the EmailSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSyncMutation) OldMessagesFailed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessagesFailed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessagesFailed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessagesFailed: %w", err)
	}
	return oldValue.MessagesFailed, nil
}

// AddMessagesFailed adds i to the "messages_failed" field.
func (m *EmailSyncMutation) AddMessagesFailed(i int) {
	if m.addmessages_failed != nil {
		*m.addmessages_failed += i
	} else {
		m.addmessages_failed = &i
	}
}

// AddedMessagesFailed returns the value that was added to the "messages_failed" field in this mutation.
func (m *EmailSyncMutation) AddedMessagesFailed() (r int, exists bool) {
	v := m.addmessages_failed
	if v == nil {
		return
	}
	return *v, true
}

// ResetMessagesFailed resets all changes to the "messages_failed" field.
func (m *EmailSyncMutation) ResetMessagesFailed() {
	m.messages_failed = nil
	m.addmessages_failed = nil
}

// SetAttachmentsDownloaded sets the "attachments_downloaded" field.
func (m *EmailSyncMutation) SetAttachmentsDownloaded(i int) {
	m.attachments_downloaded = &i
	m.addattachments_downloaded = nil
}

// AttachmentsDownloaded returns the value of the "attachments_downloaded" field in the mutation.
func (m *EmailSyncMutation) AttachmentsDownloaded() (r int, exists bool) {
	v := m.attachments_downloaded
	if v == nil {
		return
	}
	return *v, true
}

// OldAttachmentsDownloaded returns the old "attachments_downloaded" field's value of the EmailSync entity.
// If the EmailSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSyncMutation) OldAttachmentsDownloaded(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttachmentsDownloaded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttachmentsDownloaded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttachmentsDownloaded: %w", err)
	}
	return oldValue.AttachmentsDownloaded, nil
}

// AddAttachmentsDownloaded adds i to the "attachments_downloaded" field.
func (m *EmailSyncMutation) AddAttachmentsDownloaded(i int) {
	if m.addattachments_downloaded != nil {
		*m.addattachments_downloaded += i
	} else {
		m.addattachments_downloaded = &i
	}
}

// AddedAttachmentsDownloaded returns the value that was added to the "attachments_downloaded" field in this mutation.
func (m *EmailSyncMutation) AddedAttachmentsDownloaded() (r int, exists bool) {
	v := m.addattachments_downloaded
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttachmentsDownloaded resets all changes to the "attachments_downloaded" field.
func (m *EmailSyncMutation) ResetAttachmentsDownloaded() {
	m.attachments_downloaded = nil
	m.addattachments_downloaded = nil
}

// SetBytesTransferred sets the "bytes_transferred" field.
func (m *EmailSyncMutation) SetBytesTransferred(i int64) {
	m.bytes_transferred = &i
	m.addbytes_transferred = nil
}

// BytesTransferred returns the value of the "bytes_transferred" field in the mutation.
func (m *EmailSyncMutation) BytesTransferred() (r int64, exists bool) {
	v := m.bytes_transferred
	if v == nil {
		return
	}
	return *v, true
}

// OldBytesTransferred returns the old "bytes_transferred" field's value of the EmailSync entity.
// If the EmailSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSyncMutation) OldBytesTransferred(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBytesTransferred is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBytesTransferred requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBytesTransferred: %w", err)
	}
	return oldValue.BytesTransferred, nil
}

// AddBytesTransferred adds i to the "bytes_transferred" field.
func (m *EmailSyncMutation) AddBytesTransferred(i int64) {
	if m.addbytes_transferred != nil {
		*m.addbytes_transferred += i
	} else {
		m.addbytes_transferred = &i
	}
}

// AddedBytesTransferred returns the value that was added to the "bytes_transferred" field in this mutation.
func (m *EmailSyncMutation) AddedBytesTransferred() (r int64, exists bool) {
	v := m.addbytes_transferred
	if v == nil {
		return
	}
	return *v, true
}

// ResetBytesTransferred resets all changes to the "bytes_transferred" field.
func (m *EmailSyncMutation) ResetBytesTransferred() {
	m.bytes_transferred = nil
	m.addbytes_transferred = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *EmailSyncMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *EmailSyncMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the EmailSync entity.
// If the EmailSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSyncMutation) OldErrorMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *EmailSyncMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[emailsync.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *EmailSyncMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[emailsync.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *EmailSyncMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, emailsync.FieldErrorMessage)
}

// SetErrorDetails sets the "error_details" field.
func (m *EmailSyncMutation) SetErrorDetails(value map[string]interface{}) {
	m.error_details = &value
}

// ErrorDetails returns the value of the "error_details" field in the mutation.
func (m *EmailSyncMutation) ErrorDetails() (r map[string]interface{}, exists bool) {
	v := m.error_details
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorDetails returns the old "error_details" field's value of the EmailSync entity.
// If the EmailSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSyncMutation) OldErrorDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorDetails: %w", err)
	}
	return oldValue.ErrorDetails, nil
}

// ClearErrorDetails clears the value of the "error_details" field.
func (m *EmailSyncMutation) ClearErrorDetails() {
	m.error_details = nil
	m.clearedFields[emailsync.FieldErrorDetails] = struct{}{}
}

// ErrorDetailsCleared returns if the "error_details" field was cleared in this mutation.
func (m *EmailSyncMutation) ErrorDetailsCleared() bool {
	_, ok := m.clearedFields[emailsync.FieldErrorDetails]
	return ok
}

// ResetErrorDetails resets all changes to the "error_details" field.
func (m *EmailSyncMutation) ResetErrorDetails() {
	m.error_details = nil
	delete(m.clearedFields, emailsync.FieldErrorDetails)
}

// SetHistoryID sets the "history_id" field.
func (m *EmailSyncMutation) SetHistoryID(s string) {
	m.history_id = &s
}

// HistoryID returns the value of the "history_id" field in the mutation.
func (m *EmailSyncMutation) HistoryID() (r string, exists bool) {
	v := m.history_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryID returns the old "history_id" field's value of the EmailSync entity.
// If the EmailSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSyncMutation) OldHistoryID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryID: %w", err)
	}
	return oldValue.HistoryID, nil
}

// ClearHistoryID clears the value of the "history_id" field.
func (m *EmailSyncMutation) ClearHistoryID() {
	m.history_id = nil
	m.clearedFields[emailsync.FieldHistoryID] = struct{}{}
}

// HistoryIDCleared returns if the "history_id" field was cleared in this mutation.
func (m *EmailSyncMutation) HistoryIDCleared() bool {
	_, ok := m.clearedFields[emailsync.FieldHistoryID]
	return ok
}

// ResetHistoryID resets all changes to the "history_id" field.
func (m *EmailSyncMutation) ResetHistoryID() {
	m.history_id = nil
	delete(m.clearedFields, emailsync.FieldHistoryID)
}

// SetCreatedAt sets the "created_at" field.
func (m *EmailSyncMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmailSyncMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EmailSync entity.
// If the EmailSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSyncMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmailSyncMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmailSyncMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmailSyncMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EmailSync entity.
// If the EmailSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSyncMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmailSyncMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearConnection clears the "connection" edge to the EmailConnection entity.
func (m *EmailSyncMutation) ClearConnection() {
	m.clearedconnection = true
	m.clearedFields[emailsync.FieldConnectionID] = struct{}{}
}

// ConnectionCleared reports if the "connection" edge to the EmailConnection entity was cleared.
func (m *EmailSyncMutation) ConnectionCleared() bool {
	return m.clearedconnection
}

// ConnectionIDs returns the "connection" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectionID instead. It exists only for internal usage by the builders.
func (m *EmailSyncMutation) ConnectionIDs() (ids []string) {
	if id := m.connection; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnection resets all changes to the "connection" edge.
func (m *EmailSyncMutation) ResetConnection() {
	m.connection = nil
	m.clearedconnection = false
}

// Where appends a list predicates to the EmailSyncMutation builder.
func (m *EmailSyncMutation) Where(ps ...predicate.EmailSync) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailSyncMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailSyncMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmailSync, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailSyncMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailSyncMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmailSync).
func (m *EmailSyncMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailSyncMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.connection != nil {
		fields = append(fields, emailsync.FieldConnectionID)
	}
	if m.label_id != nil {
		fields = append(fields, emailsync.FieldLabelID)
	}
	if m.sync_type != nil {
		fields = append(fields, emailsync.FieldSyncType)
	}
	if m.status != nil {
		fields = append(fields, emailsync.FieldStatus)
	}
	if m.started_at != nil {
		fields = append(fields, emailsync.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, emailsync.FieldCompletedAt)
	}
	if m.messages_scanned != nil {
		fields = append(fields, emailsync.FieldMessagesScanned)
	}
	if m.messages_downloaded != nil {
		fields = append(fields, emailsync.FieldMessagesDownloaded)
	}
	if m.messages_indexed != nil {
		fields = append(fields, emailsync.FieldMessagesIndexed)
	}
	if m.messages_failed != nil {
		fields = append(fields, emailsync.FieldMessagesFailed)
	}
	if m.attachments_downloaded != nil {
		fields = append(fields, emailsync.FieldAttachmentsDownloaded)
	}
	if m.bytes_transferred != nil {
		fields = append(fields, emailsync.FieldBytesTransferred)
	}
	if m.error_message != nil {
		fields = append(fields, emailsync.FieldErrorMessage)
	}
	if m.error_details != nil {
		fields = append(fields, emailsync.FieldErrorDetails)
	}
	if m.history_id != nil {
		fields = append(fields, emailsync.FieldHistoryID)
	}
	if m.created_at != nil {
		fields = append(fields, emailsync.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, emailsync.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailSyncMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emailsync.FieldConnectionID:
		return m.ConnectionID()
	case emailsync.FieldLabelID:
		return m.LabelID()
	case emailsync.FieldSyncType:
		return m.SyncType()
	case emailsync.FieldStatus:
		return m.Status()
	case emailsync.FieldStartedAt:
		return m.StartedAt()
	case emailsync.FieldCompletedAt:
		return m.CompletedAt()
	case emailsync.FieldMessagesScanned:
		return m.MessagesScanned()
	case emailsync.FieldMessagesDownloaded:
		return m.MessagesDownloaded()
	case emailsync.FieldMessagesIndexed:
		return m.MessagesIndexed()
	case emailsync.FieldMessagesFailed:
		return m.MessagesFailed()
	case emailsync.FieldAttachmentsDownloaded:
		return m.AttachmentsDownloaded()
	case emailsync.FieldBytesTransferred:
		return m.BytesTransferred()
	case emailsync.FieldErrorMessage:
		return m.ErrorMessage()
	case emailsync.FieldErrorDetails:
		return m.ErrorDetails()
	case emailsync.FieldHistoryID:
		return m.HistoryID()
	case emailsync.FieldCreatedAt:
		return m.CreatedAt()
	case emailsync.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailSyncMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emailsync.FieldConnectionID:
		return m.OldConnectionID(ctx)
	case emailsync.FieldLabelID:
		return m.OldLabelID(ctx)
	case emailsync.FieldSyncType:
		return m.OldSyncType(ctx)
	case emailsync.FieldStatus:
		return m.OldStatus(ctx)
	case emailsync.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case emailsync.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case emailsync.FieldMessagesScanned:
		return m.OldMessagesScanned(ctx)
	case emailsync.FieldMessagesDownloaded:
		return m.OldMessagesDownloaded(ctx)
	case emailsync.FieldMessagesIndexed:
		return m.OldMessagesIndexed(ctx)
	case emailsync.FieldMessagesFailed:
		return m.OldMessagesFailed(ctx)
	case emailsync.FieldAttachmentsDownloaded:
		return m.OldAttachmentsDownloaded(ctx)
	case emailsync.FieldBytesTransferred:
		return m.OldBytesTransferred(ctx)
	case emailsync.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case emailsync.FieldErrorDetails:
		return m.OldErrorDetails(ctx)
	case emailsync.FieldHistoryID:
		return m.OldHistoryID(ctx)
	case emailsync.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case emailsync.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown EmailSync field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailSyncMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emailsync.FieldConnectionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectionID(v)
		return nil
	case emailsync.FieldLabelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabelID(v)
		return nil
	case emailsync.FieldSyncType:
		v, ok := value.(emailsync.SyncType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncType(v)
		return nil
	case emailsync.FieldStatus:
		v, ok := value.(emailsync.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case emailsync.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case emailsync.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case emailsync.FieldMessagesScanned:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessagesScanned(v)
		return nil
	case emailsync.FieldMessagesDownloaded:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessagesDownloaded(v)
		return nil
	case emailsync.FieldMessagesIndexed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessagesIndexed(v)
		return nil
	case emailsync.FieldMessagesFailed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessagesFailed(v)
		return nil
	case emailsync.FieldAttachmentsDownloaded:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttachmentsDownloaded(v)
		return nil
	case emailsync.FieldBytesTransferred:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBytesTransferred(v)
		return nil
	case emailsync.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case emailsync.FieldErrorDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorDetails(v)
		return nil
	case emailsync.FieldHistoryID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryID(v)
		return nil
	case emailsync.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case emailsync.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown EmailSync field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailSyncMutation) AddedFields() []string {
	var fields []string
	if m.addmessages_scanned != nil {
		fields = append(fields, emailsync.FieldMessagesScanned)
	}
	if m.addmessages_downloaded != nil {
		fields = append(fields, emailsync.FieldMessagesDownloaded)
	}
	if m.addmessages_indexed != nil {
		fields = append(fields, emailsync.FieldMessagesIndexed)
	}
	if m.addmessages_failed != nil {
		fields = append(fields, emailsync.FieldMessagesFailed)
	}
	if m.addattachments_downloaded != nil {
		fields = append(fields, emailsync.FieldAttachmentsDownloaded)
	}
	if m.addbytes_transferred != nil {
		fields = append(fields, emailsync.FieldBytesTransferred)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailSyncMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case emailsync.FieldMessagesScanned:
		return m.AddedMessagesScanned()
	case emailsync.FieldMessagesDownloaded:
		return m.AddedMessagesDownloaded()
	case emailsync.FieldMessagesIndexed:
		return m.AddedMessagesIndexed()
	case emailsync.FieldMessagesFailed:
		return m.AddedMessagesFailed()
	case emailsync.FieldAttachmentsDownloaded:
		return m.AddedAttachmentsDownloaded()
	case emailsync.FieldBytesTransferred:
		return m.AddedBytesTransferred()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailSyncMutation) AddField(name string, value ent.Value) error {
	switch name {
	case emailsync.FieldMessagesScanned:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMessagesScanned(v)
		return nil
	case emailsync.FieldMessagesDownloaded:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMessagesDownloaded(v)
		return nil
	case emailsync.FieldMessagesIndexed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMessagesIndexed(v)
		return nil
	case emailsync.FieldMessagesFailed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMessagesFailed(v)
		return nil
	case emailsync.FieldAttachmentsDownloaded:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttachmentsDownloaded(v)
		return nil
	case emailsync.FieldBytesTransferred:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBytesTransferred(v)
		return nil
	}
	return fmt.Errorf("unknown EmailSync numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailSyncMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(emailsync.FieldLabelID) {
		fields = append(fields, emailsync.FieldLabelID)
	}
	if m.FieldCleared(emailsync.FieldStartedAt) {
		fields = append(fields, emailsync.FieldStartedAt)
	}
	if m.FieldCleared(emailsync.FieldCompletedAt) {
		fields = append(fields, emailsync.FieldCompletedAt)
	}
	if m.FieldCleared(emailsync.FieldErrorMessage) {
		fields = append(fields, emailsync.FieldErrorMessage)
	}
	if m.FieldCleared(emailsync.FieldErrorDetails) {
		fields = append(fields, emailsync.FieldErrorDetails)
	}
	if m.FieldCleared(emailsync.FieldHistoryID) {
		fields = append(fields, emailsync.FieldHistoryID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailSyncMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailSyncMutation) ClearField(name string) error {
	switch name {
	case emailsync.FieldLabelID:
		m.ClearLabelID()
		return nil
	case emailsync.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case emailsync.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case emailsync.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case emailsync.FieldErrorDetails:
		m.ClearErrorDetails()
		return nil
	case emailsync.FieldHistoryID:
		m.ClearHistoryID()
		return nil
	}
	return fmt.Errorf("unknown EmailSync nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailSyncMutation) ResetField(name string) error {
	switch name {
	case emailsync.FieldConnectionID:
		m.ResetConnectionID()
		return nil
	case emailsync.FieldLabelID:
		m.ResetLabelID()
		return nil
	case emailsync.FieldSyncType:
		m.ResetSyncType()
		return nil
	case emailsync.FieldStatus:
		m.ResetStatus()
		return nil
	case emailsync.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case emailsync.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case emailsync.FieldMessagesScanned:
		m.ResetMessagesScanned()
		return nil
	case emailsync.FieldMessagesDownloaded:
		m.ResetMessagesDownloaded()
		return nil
	case emailsync.FieldMessagesIndexed:
		m.ResetMessagesIndexed()
		return nil
	case emailsync.FieldMessagesFailed:
		m.ResetMessagesFailed()
		return nil
	case emailsync.FieldAttachmentsDownloaded:
		m.ResetAttachmentsDownloaded()
		return nil
	case emailsync.FieldBytesTransferred:
		m.ResetBytesTransferred()
		return nil
	case emailsync.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case emailsync.FieldErrorDetails:
		m.ResetErrorDetails()
		return nil
	case emailsync.FieldHistoryID:
		m.ResetHistoryID()
		return nil
	case emailsync.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case emailsync.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown EmailSync field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailSyncMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.connection != nil {
		edges = append(edges, emailsync.EdgeConnection)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailSyncMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case emailsync.EdgeConnection:
		if id := m.connection; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailSyncMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailSyncMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailSyncMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedconnection {
		edges = append(edges, emailsync.EdgeConnection)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailSyncMutation) EdgeCleared(name string) bool {
	switch name {
	case emailsync.EdgeConnection:
		return m.clearedconnection
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailSyncMutation) ClearEdge(name string) error {
	switch name {
	case emailsync.EdgeConnection:
		m.ClearConnection()
		return nil
	}
	return fmt.Errorf("unknown EmailSync unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailSyncMutation) ResetEdge(name string) error {
	switch name {
	case emailsync.EdgeConnection:
		m.ResetConnection()
		return nil
	}
	return fmt.Errorf("unknown EmailSync edge %s", name)
}

// GoogleDriveConnectionMutation represents an operation that mutates the GoogleDriveConnection nodes in the graph.
type GoogleDriveConnectionMutation struct {
	config
	op                Op
	typ               string
	id                *string
	user_id           *string
	google_account_id *string
	email             *string
	access_token      *string
	refresh_token     *string
	token_expiry      *time.Time
	status            *googledriveconnection.Status
	created_at        *time.Time
	updated_at        *time.Time
	last_sync_at      *time.Time
	clearedFields     map[string]struct{}
	folders           map[string]struct{}
	removedfolders    map[string]struct{}
	clearedfolders    bool
	syncs             map[string]struct{}
	removedsyncs      map[string]struct{}
	clearedsyncs      bool
	done              bool
	oldValue          func(context.Context) (*GoogleDriveConnection, error)
	predicates        []predicate.GoogleDriveConnection
}

var _ ent.Mutation = (*GoogleDriveConnectionMutation)(nil)

// googledriveconnectionOption allows management of the mutation configuration using functional options.
type googledriveconnectionOption func(*GoogleDriveConnectionMutation)

// newGoogleDriveConnectionMutation creates new mutation for the GoogleDriveConnection entity.
func newGoogleDriveConnectionMutation(c config, op Op, opts ...googledriveconnectionOption) *GoogleDriveConnectionMutation {
	m := &GoogleDriveConnectionMutation{
		config:        c,
		op:            op,
		typ:           TypeGoogleDriveConnection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoogleDriveConnectionID sets the ID field of the mutation.
func withGoogleDriveConnectionID(id string) googledriveconnectionOption {
	return func(m *GoogleDriveConnectionMutation) {
		var (
			err   error
			once  sync.Once
			value *GoogleDriveConnection
		)
		m.oldValue = func(ctx context.Context) (*GoogleDriveConnection, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoogleDriveConnection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoogleDriveConnection sets the old GoogleDriveConnection of the mutation.
func withGoogleDriveConnection(node *GoogleDriveConnection) googledriveconnectionOption {
	return func(m *GoogleDriveConnectionMutation) {
		m.oldValue = func(context.Context) (*GoogleDriveConnection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoogleDriveConnectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoogleDriveConnectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GoogleDriveConnection entities.
func (m *GoogleDriveConnectionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoogleDriveConnectionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoogleDriveConnectionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoogleDriveConnection.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *GoogleDriveConnectionMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *GoogleDriveConnectionMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the GoogleDriveConnection entity.
// If the GoogleDriveConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveConnectionMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *GoogleDriveConnectionMutation) ResetUserID() {
	m.user_id = nil
}

// SetGoogleAccountID sets the "google_account_id" field.
func (m *GoogleDriveConnectionMutation) SetGoogleAccountID(s string) {
	m.google_account_id = &s
}

// GoogleAccountID returns the value of the "google_account_id" field in the mutation.
func (m *GoogleDriveConnectionMutation) GoogleAccountID() (r string, exists bool) {
	v := m.google_account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoogleAccountID returns the old "google_account_id" field's value of the GoogleDriveConnection entity.
// If the GoogleDriveConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveConnectionMutation) OldGoogleAccountID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoogleAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoogleAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoogleAccountID: %w", err)
	}
	return oldValue.GoogleAccountID, nil
}

// ResetGoogleAccountID resets all changes to the "google_account_id" field.
func (m *GoogleDriveConnectionMutation) ResetGoogleAccountID() {
	m.google_account_id = nil
}

// SetEmail sets the "email" field.
func (m *GoogleDriveConnectionMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *GoogleDriveConnectionMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the GoogleDriveConnection entity.
// If the GoogleDriveConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveConnectionMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *GoogleDriveConnectionMutation) ResetEmail() {
	m.email = nil
}

// SetAccessToken sets the "access_token" field.
func (m *GoogleDriveConnectionMutation) SetAccessToken(s string) {
	m.access_token = &s
}

// AccessToken returns the value of the "access_token" field in the mutation.
func (m *GoogleDriveConnectionMutation) AccessToken() (r string, exists bool) {
	v := m.access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessToken returns the old "access_token" field's value of the GoogleDriveConnection entity.
// If the GoogleDriveConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveConnectionMutation) OldAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessToken: %w", err)
	}
	return oldValue.AccessToken, nil
}

// ResetAccessToken resets all changes to the "access_token" field.
func (m *GoogleDriveConnectionMutation) ResetAccessToken() {
	m.access_token = nil
}

// SetRefreshToken sets the "refresh_token" field.
func (m *GoogleDriveConnectionMutation) SetRefreshToken(s string) {
	m.refresh_token = &s
}

// RefreshToken returns the value of the "refresh_token" field in the mutation.
func (m *GoogleDriveConnectionMutation) RefreshToken() (r string, exists bool) {
	v := m.refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshToken returns the old "refresh_token" field's value of the GoogleDriveConnection entity.
// If the GoogleDriveConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveConnectionMutation) OldRefreshToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshToken: %w", err)
	}
	return oldValue.RefreshToken, nil
}

// ResetRefreshToken resets all changes to the "refresh_token" field.
func (m *GoogleDriveConnectionMutation) ResetRefreshToken() {
	m.refresh_token = nil
}

// SetTokenExpiry sets the "token_expiry" field.
func (m *GoogleDriveConnectionMutation) SetTokenExpiry(t time.Time) {
	m.token_expiry = &t
}

// TokenExpiry returns the value of the "token_expiry" field in the mutation.
func (m *GoogleDriveConnectionMutation) TokenExpiry() (r time.Time, exists bool) {
	v := m.token_expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenExpiry returns the old "token_expiry" field's value of the GoogleDriveConnection entity.
// If the GoogleDriveConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveConnectionMutation) OldTokenExpiry(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenExpiry: %w", err)
	}
	return oldValue.TokenExpiry, nil
}

// ResetTokenExpiry resets all changes to the "token_expiry" field.
func (m *GoogleDriveConnectionMutation) ResetTokenExpiry() {
	m.token_expiry = nil
}

// SetStatus sets the "status" field.
func (m *GoogleDriveConnectionMutation) SetStatus(_go googledriveconnection.Status) {
	m.status = &_go
}

// Status returns the value of the "status" field in the mutation.
func (m *GoogleDriveConnectionMutation) Status() (r googledriveconnection.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the GoogleDriveConnection entity.
// If the GoogleDriveConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveConnectionMutation) OldStatus(ctx context.Context) (v googledriveconnection.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *GoogleDriveConnectionMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GoogleDriveConnectionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoogleDriveConnectionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoogleDriveConnection entity.
// If the GoogleDriveConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveConnectionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoogleDriveConnectionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoogleDriveConnectionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoogleDriveConnectionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoogleDriveConnection entity.
// If the GoogleDriveConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveConnectionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoogleDriveConnectionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLastSyncAt sets the "last_sync_at" field.
func (m *GoogleDriveConnectionMutation) SetLastSyncAt(t time.Time) {
	m.last_sync_at = &t
}

// LastSyncAt returns the value of the "last_sync_at" field in the mutation.
func (m *GoogleDriveConnectionMutation) LastSyncAt() (r time.Time, exists bool) {
	v := m.last_sync_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSyncAt returns the old "last_sync_at" field's value of the GoogleDriveConnection entity.
// If the GoogleDriveConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveConnectionMutation) OldLastSyncAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSyncAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSyncAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSyncAt: %w", err)
	}
	return oldValue.LastSyncAt, nil
}

// ClearLastSyncAt clears the value of the "last_sync_at" field.
func (m *GoogleDriveConnectionMutation) ClearLastSyncAt() {
	m.last_sync_at = nil
	m.clearedFields[googledriveconnection.FieldLastSyncAt] = struct{}{}
}

// LastSyncAtCleared returns if the "last_sync_at" field was cleared in this mutation.
func (m *GoogleDriveConnectionMutation) LastSyncAtCleared() bool {
	_, ok := m.clearedFields[googledriveconnection.FieldLastSyncAt]
	return ok
}

// ResetLastSyncAt resets all changes to the "last_sync_at" field.
func (m *GoogleDriveConnectionMutation) ResetLastSyncAt() {
	m.last_sync_at = nil
	delete(m.clearedFields, googledriveconnection.FieldLastSyncAt)
}

// AddFolderIDs adds the "folders" edge to the GoogleDriveFolder entity by ids.
func (m *GoogleDriveConnectionMutation) AddFolderIDs(ids ...string) {
	if m.folders == nil {
		m.folders = make(map[string]struct{})
	}
	for i := range ids {
		m.folders[ids[i]] = struct{}{}
	}
}

// ClearFolders clears the "folders" edge to the GoogleDriveFolder entity.
func (m *GoogleDriveConnectionMutation) ClearFolders() {
	m.clearedfolders = true
}

// FoldersCleared reports if the "folders" edge to the GoogleDriveFolder entity was cleared.
func (m *GoogleDriveConnectionMutation) FoldersCleared() bool {
	return m.clearedfolders
}

// RemoveFolderIDs removes the "folders" edge to the GoogleDriveFolder entity by IDs.
func (m *GoogleDriveConnectionMutation) RemoveFolderIDs(ids ...string) {
	if m.removedfolders == nil {
		m.removedfolders = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.folders, ids[i])
		m.removedfolders[ids[i]] = struct{}{}
	}
}

// RemovedFolders returns the removed IDs of the "folders" edge to the GoogleDriveFolder entity.
func (m *GoogleDriveConnectionMutation) RemovedFoldersIDs() (ids []string) {
	for id := range m.removedfolders {
		ids = append(ids, id)
	}
	return
}

// FoldersIDs returns the "folders" edge IDs in the mutation.
func (m *GoogleDriveConnectionMutation) FoldersIDs() (ids []string) {
	for id := range m.folders {
		ids = append(ids, id)
	}
	return
}

// ResetFolders resets all changes to the "folders" edge.
func (m *GoogleDriveConnectionMutation) ResetFolders() {
	m.folders = nil
	m.clearedfolders = false
	m.removedfolders = nil
}

// AddSyncIDs adds the "syncs" edge to the GoogleDriveSync entity by ids.
func (m *GoogleDriveConnectionMutation) AddSyncIDs(ids ...string) {
	if m.syncs == nil {
		m.syncs = make(map[string]struct{})
	}
	for i := range ids {
		m.syncs[ids[i]] = struct{}{}
	}
}

// ClearSyncs clears the "syncs" edge to the GoogleDriveSync entity.
func (m *GoogleDriveConnectionMutation) ClearSyncs() {
	m.clearedsyncs = true
}

// SyncsCleared reports if the "syncs" edge to the GoogleDriveSync entity was cleared.
func (m *GoogleDriveConnectionMutation) SyncsCleared() bool {
	return m.clearedsyncs
}

// RemoveSyncIDs removes the "syncs" edge to the GoogleDriveSync entity by IDs.
func (m *GoogleDriveConnectionMutation) RemoveSyncIDs(ids ...string) {
	if m.removedsyncs == nil {
		m.removedsyncs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.syncs, ids[i])
		m.removedsyncs[ids[i]] = struct{}{}
	}
}

// RemovedSyncs returns the removed IDs of the "syncs" edge to the GoogleDriveSync entity.
func (m *GoogleDriveConnectionMutation) RemovedSyncsIDs() (ids []string) {
	for id := range m.removedsyncs {
		ids = append(ids, id)
	}
	return
}

// SyncsIDs returns the "syncs" edge IDs in the mutation.
func (m *GoogleDriveConnectionMutation) SyncsIDs() (ids []string) {
	for id := range m.syncs {
		ids = append(ids, id)
	}
	return
}

// ResetSyncs resets all changes to the "syncs" edge.
func (m *GoogleDriveConnectionMutation) ResetSyncs() {
	m.syncs = nil
	m.clearedsyncs = false
	m.removedsyncs = nil
}

// Where appends a list predicates to the GoogleDriveConnectionMutation builder.
func (m *GoogleDriveConnectionMutation) Where(ps ...predicate.GoogleDriveConnection) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GoogleDriveConnectionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GoogleDriveConnectionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GoogleDriveConnection, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GoogleDriveConnectionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GoogleDriveConnectionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GoogleDriveConnection).
func (m *GoogleDriveConnectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoogleDriveConnectionMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.user_id != nil {
		fields = append(fields, googledriveconnection.FieldUserID)
	}
	if m.google_account_id != nil {
		fields = append(fields, googledriveconnection.FieldGoogleAccountID)
	}
	if m.email != nil {
		fields = append(fields, googledriveconnection.FieldEmail)
	}
	if m.access_token != nil {
		fields = append(fields, googledriveconnection.FieldAccessToken)
	}
	if m.refresh_token != nil {
		fields = append(fields, googledriveconnection.FieldRefreshToken)
	}
	if m.token_expiry != nil {
		fields = append(fields, googledriveconnection.FieldTokenExpiry)
	}
	if m.status != nil {
		fields = append(fields, googledriveconnection.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, googledriveconnection.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, googledriveconnection.FieldUpdatedAt)
	}
	if m.last_sync_at != nil {
		fields = append(fields, googledriveconnection.FieldLastSyncAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoogleDriveConnectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case googledriveconnection.FieldUserID:
		return m.UserID()
	case googledriveconnection.FieldGoogleAccountID:
		return m.GoogleAccountID()
	case googledriveconnection.FieldEmail:
		return m.Email()
	case googledriveconnection.FieldAccessToken:
		return m.AccessToken()
	case googledriveconnection.FieldRefreshToken:
		return m.RefreshToken()
	case googledriveconnection.FieldTokenExpiry:
		return m.TokenExpiry()
	case googledriveconnection.FieldStatus:
		return m.Status()
	case googledriveconnection.FieldCreatedAt:
		return m.CreatedAt()
	case googledriveconnection.FieldUpdatedAt:
		return m.UpdatedAt()
	case googledriveconnection.FieldLastSyncAt:
		return m.LastSyncAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoogleDriveConnectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case googledriveconnection.FieldUserID:
		return m.OldUserID(ctx)
	case googledriveconnection.FieldGoogleAccountID:
		return m.OldGoogleAccountID(ctx)
	case googledriveconnection.FieldEmail:
		return m.OldEmail(ctx)
	case googledriveconnection.FieldAccessToken:
		return m.OldAccessToken(ctx)
	case googledriveconnection.FieldRefreshToken:
		return m.OldRefreshToken(ctx)
	case googledriveconnection.FieldTokenExpiry:
		return m.OldTokenExpiry(ctx)
	case googledriveconnection.FieldStatus:
		return m.OldStatus(ctx)
	case googledriveconnection.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case googledriveconnection.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case googledriveconnection.FieldLastSyncAt:
		return m.OldLastSyncAt(ctx)
	}
	return nil, fmt.Errorf("unknown GoogleDriveConnection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoogleDriveConnectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case googledriveconnection.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case googledriveconnection.FieldGoogleAccountID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoogleAccountID(v)
		return nil
	case googledriveconnection.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case googledriveconnection.FieldAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessToken(v)
		return nil
	case googledriveconnection.FieldRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshToken(v)
		return nil
	case googledriveconnection.FieldTokenExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenExpiry(v)
		return nil
	case googledriveconnection.FieldStatus:
		v, ok := value.(googledriveconnection.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case googledriveconnection.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case googledriveconnection.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case googledriveconnection.FieldLastSyncAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSyncAt(v)
		return nil
	}
	return fmt.Errorf("unknown GoogleDriveConnection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoogleDriveConnectionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoogleDriveConnectionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoogleDriveConnectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GoogleDriveConnection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoogleDriveConnectionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(googledriveconnection.FieldLastSyncAt) {
		fields = append(fields, googledriveconnection.FieldLastSyncAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoogleDriveConnectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoogleDriveConnectionMutation) ClearField(name string) error {
	switch name {
	case googledriveconnection.FieldLastSyncAt:
		m.ClearLastSyncAt()
		return nil
	}
	return fmt.Errorf("unknown GoogleDriveConnection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoogleDriveConnectionMutation) ResetField(name string) error {
	switch name {
	case googledriveconnection.FieldUserID:
		m.ResetUserID()
		return nil
	case googledriveconnection.FieldGoogleAccountID:
		m.ResetGoogleAccountID()
		return nil
	case googledriveconnection.FieldEmail:
		m.ResetEmail()
		return nil
	case googledriveconnection.FieldAccessToken:
		m.ResetAccessToken()
		return nil
	case googledriveconnection.FieldRefreshToken:
		m.ResetRefreshToken()
		return nil
	case googledriveconnection.FieldTokenExpiry:
		m.ResetTokenExpiry()
		return nil
	case googledriveconnection.FieldStatus:
		m.ResetStatus()
		return nil
	case googledriveconnection.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case googledriveconnection.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case googledriveconnection.FieldLastSyncAt:
		m.ResetLastSyncAt()
		return nil
	}
	return fmt.Errorf("unknown GoogleDriveConnection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoogleDriveConnectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.folders != nil {
		edges = append(edges, googledriveconnection.EdgeFolders)
	}
	if m.syncs != nil {
		edges = append(edges, googledriveconnection.EdgeSyncs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoogleDriveConnectionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case googledriveconnection.EdgeFolders:
		ids := make([]ent.Value, 0, len(m.folders))
		for id := range m.folders {
			ids = append(ids, id)
		}
		return ids
	case googledriveconnection.EdgeSyncs:
		ids := make([]ent.Value, 0, len(m.syncs))
		for id := range m.syncs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoogleDriveConnectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedfolders != nil {
		edges = append(edges, googledriveconnection.EdgeFolders)
	}
	if m.removedsyncs != nil {
		edges = append(edges, googledriveconnection.EdgeSyncs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoogleDriveConnectionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case googledriveconnection.EdgeFolders:
		ids := make([]ent.Value, 0, len(m.removedfolders))
		for id := range m.removedfolders {
			ids = append(ids, id)
		}
		return ids
	case googledriveconnection.EdgeSyncs:
		ids := make([]ent.Value, 0, len(m.removedsyncs))
		for id := range m.removedsyncs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoogleDriveConnectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfolders {
		edges = append(edges, googledriveconnection.EdgeFolders)
	}
	if m.clearedsyncs {
		edges = append(edges, googledriveconnection.EdgeSyncs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoogleDriveConnectionMutation) EdgeCleared(name string) bool {
	switch name {
	case googledriveconnection.EdgeFolders:
		return m.clearedfolders
	case googledriveconnection.EdgeSyncs:
		return m.clearedsyncs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoogleDriveConnectionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown GoogleDriveConnection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoogleDriveConnectionMutation) ResetEdge(name string) error {
	switch name {
	case googledriveconnection.EdgeFolders:
		m.ResetFolders()
		return nil
	case googledriveconnection.EdgeSyncs:
		m.ResetSyncs()
		return nil
	}
	return fmt.Errorf("unknown GoogleDriveConnection edge %s", name)
}

// GoogleDriveFolderMutation represents an operation that mutates the GoogleDriveFolder nodes in the graph.
type GoogleDriveFolderMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	drive_folder_id     *string
	name                *string
	_path               *string
	parent_folder_id    *string
	is_root             *bool
	sync_enabled        *bool
	sync_direction      *googledrivefolder.SyncDirection
	file_count          *int64
	addfile_count       *int64
	total_size_bytes    *int64
	addtotal_size_bytes *int64
	created_at          *time.Time
	updated_at          *time.Time
	last_scanned_at     *time.Time
	clearedFields       map[string]struct{}
	connection          *string
	clearedconnection   bool
	done                bool
	oldValue            func(context.Context) (*GoogleDriveFolder, error)
	predicates          []predicate.GoogleDriveFolder
}

var _ ent.Mutation = (*GoogleDriveFolderMutation)(nil)

// googledrivefolderOption allows management of the mutation configuration using functional options.
type googledrivefolderOption func(*GoogleDriveFolderMutation)

// newGoogleDriveFolderMutation creates new mutation for the GoogleDriveFolder entity.
func newGoogleDriveFolderMutation(c config, op Op, opts ...googledrivefolderOption) *GoogleDriveFolderMutation {
	m := &GoogleDriveFolderMutation{
		config:        c,
		op:            op,
		typ:           TypeGoogleDriveFolder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoogleDriveFolderID sets the ID field of the mutation.
func withGoogleDriveFolderID(id string) googledrivefolderOption {
	return func(m *GoogleDriveFolderMutation) {
		var (
			err   error
			once  sync.Once
			value *GoogleDriveFolder
		)
		m.oldValue = func(ctx context.Context) (*GoogleDriveFolder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoogleDriveFolder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoogleDriveFolder sets the old GoogleDriveFolder of the mutation.
func withGoogleDriveFolder(node *GoogleDriveFolder) googledrivefolderOption {
	return func(m *GoogleDriveFolderMutation) {
		m.oldValue = func(context.Context) (*GoogleDriveFolder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoogleDriveFolderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoogleDriveFolderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GoogleDriveFolder entities.
func (m *GoogleDriveFolderMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoogleDriveFolderMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoogleDriveFolderMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoogleDriveFolder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetConnectionID sets the "connection_id" field.
func (m *GoogleDriveFolderMutation) SetConnectionID(s string) {
	m.connection = &s
}

// ConnectionID returns the value of the "connection_id" field in the mutation.
func (m *GoogleDriveFolderMutation) ConnectionID() (r string, exists bool) {
	v := m.connection
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectionID returns the old "connection_id" field's value of the GoogleDriveFolder entity.
// If the GoogleDriveFolder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveFolderMutation) OldConnectionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectionID: %w", err)
	}
	return oldValue.ConnectionID, nil
}

// ResetConnectionID resets all changes to the "connection_id" field.
func (m *GoogleDriveFolderMutation) ResetConnectionID() {
	m.connection = nil
}

// SetDriveFolderID sets the "drive_folder_id" field.
func (m *GoogleDriveFolderMutation) SetDriveFolderID(s string) {
	m.drive_folder_id = &s
}

// DriveFolderID returns the value of the "drive_folder_id" field in the mutation.
func (m *GoogleDriveFolderMutation) DriveFolderID() (r string, exists bool) {
	v := m.drive_folder_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDriveFolderID returns the old "drive_folder_id" field's value of the GoogleDriveFolder entity.
// If the GoogleDriveFolder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveFolderMutation) OldDriveFolderID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDriveFolderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDriveFolderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDriveFolderID: %w", err)
	}
	return oldValue.DriveFolderID, nil
}

// ResetDriveFolderID resets all changes to the "drive_folder_id" field.
func (m *GoogleDriveFolderMutation) ResetDriveFolderID() {
	m.drive_folder_id = nil
}

// SetName sets the "name" field.
func (m *GoogleDriveFolderMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GoogleDriveFolderMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the GoogleDriveFolder entity.
// If the GoogleDriveFolder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveFolderMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GoogleDriveFolderMutation) ResetName() {
	m.name = nil
}

// SetPath sets the "path" field.
func (m *GoogleDriveFolderMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *GoogleDriveFolderMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the GoogleDriveFolder entity.
// If the GoogleDriveFolder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveFolderMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *GoogleDriveFolderMutation) ClearPath() {
	m._path = nil
	m.clearedFields[googledrivefolder.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *GoogleDriveFolderMutation) PathCleared() bool {
	_, ok := m.clearedFields[googledrivefolder.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *GoogleDriveFolderMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, googledrivefolder.FieldPath)
}

// SetParentFolderID sets the "parent_folder_id" field.
func (m *GoogleDriveFolderMutation) SetParentFolderID(s string) {
	m.parent_folder_id = &s
}

// ParentFolderID returns the value of the "parent_folder_id" field in the mutation.
func (m *GoogleDriveFolderMutation) ParentFolderID() (r string, exists bool) {
	v := m.parent_folder_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentFolderID returns the old "parent_folder_id" field's value of the GoogleDriveFolder entity.
// If the GoogleDriveFolder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveFolderMutation) OldParentFolderID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentFolderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentFolderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentFolderID: %w", err)
	}
	return oldValue.ParentFolderID, nil
}

// ClearParentFolderID clears the value of the "parent_folder_id" field.
func (m *GoogleDriveFolderMutation) ClearParentFolderID() {
	m.parent_folder_id = nil
	m.clearedFields[googledrivefolder.FieldParentFolderID] = struct{}{}
}

// ParentFolderIDCleared returns if the "parent_folder_id" field was cleared in this mutation.
func (m *GoogleDriveFolderMutation) ParentFolderIDCleared() bool {
	_, ok := m.clearedFields[googledrivefolder.FieldParentFolderID]
	return ok
}

// ResetParentFolderID resets all changes to the "parent_folder_id" field.
func (m *GoogleDriveFolderMutation) ResetParentFolderID() {
	m.parent_folder_id = nil
	delete(m.clearedFields, googledrivefolder.FieldParentFolderID)
}

// SetIsRoot sets the "is_root" field.
func (m *GoogleDriveFolderMutation) SetIsRoot(b bool) {
	m.is_root = &b
}

// IsRoot returns the value of the "is_root" field in the mutation.
func (m *GoogleDriveFolderMutation) IsRoot() (r bool, exists bool) {
	v := m.is_root
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRoot returns the old "is_root" field's value of the GoogleDriveFolder entity.
// If the GoogleDriveFolder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveFolderMutation) OldIsRoot(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRoot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRoot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRoot: %w", err)
	}
	return oldValue.IsRoot, nil
}

// ResetIsRoot resets all changes to the "is_root" field.
func (m *GoogleDriveFolderMutation) ResetIsRoot() {
	m.is_root = nil
}

// SetSyncEnabled sets the "sync_enabled" field.
func (m *GoogleDriveFolderMutation) SetSyncEnabled(b bool) {
	m.sync_enabled = &b
}

// SyncEnabled returns the value of the "sync_enabled" field in the mutation.
func (m *GoogleDriveFolderMutation) SyncEnabled() (r bool, exists bool) {
	v := m.sync_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncEnabled returns the old "sync_enabled" field's value of the GoogleDriveFolder entity.
// If the GoogleDriveFolder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveFolderMutation) OldSyncEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncEnabled: %w", err)
	}
	return oldValue.SyncEnabled, nil
}

// ResetSyncEnabled resets all changes to the "sync_enabled" field.
func (m *GoogleDriveFolderMutation) ResetSyncEnabled() {
	m.sync_enabled = nil
}

// SetSyncDirection sets the "sync_direction" field.
func (m *GoogleDriveFolderMutation) SetSyncDirection(gd googledrivefolder.SyncDirection) {
	m.sync_direction = &gd
}

// SyncDirection returns the value of the "sync_direction" field in the mutation.
func (m *GoogleDriveFolderMutation) SyncDirection() (r googledrivefolder.SyncDirection, exists bool) {
	v := m.sync_direction
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncDirection returns the old "sync_direction" field's value of the GoogleDriveFolder entity.
// If the GoogleDriveFolder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveFolderMutation) OldSyncDirection(ctx context.Context) (v googledrivefolder.SyncDirection, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncDirection is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncDirection requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncDirection: %w", err)
	}
	return oldValue.SyncDirection, nil
}

// ResetSyncDirection resets all changes to the "sync_direction" field.
func (m *GoogleDriveFolderMutation) ResetSyncDirection() {
	m.sync_direction = nil
}

// SetFileCount sets the "file_count" field.
func (m *GoogleDriveFolderMutation) SetFileCount(i int64) {
	m.file_count = &i
	m.addfile_count = nil
}

// FileCount returns the value of the "file_count" field in the mutation.
func (m *GoogleDriveFolderMutation) FileCount() (r int64, exists bool) {
	v := m.file_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFileCount returns the old "file_count" field's value of the GoogleDriveFolder entity.
// If the GoogleDriveFolder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveFolderMutation) OldFileCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileCount: %w", err)
	}
	return oldValue.FileCount, nil
}

// AddFileCount adds i to the "file_count" field.
func (m *GoogleDriveFolderMutation) AddFileCount(i int64) {
	if m.addfile_count != nil {
		*m.addfile_count += i
	} else {
		m.addfile_count = &i
	}
}

// AddedFileCount returns the value that was added to the "file_count" field in this mutation.
func (m *GoogleDriveFolderMutation) AddedFileCount() (r int64, exists bool) {
	v := m.addfile_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFileCount resets all changes to the "file_count" field.
func (m *GoogleDriveFolderMutation) ResetFileCount() {
	m.file_count = nil
	m.addfile_count = nil
}

// SetTotalSizeBytes sets the "total_size_bytes" field.
func (m *GoogleDriveFolderMutation) SetTotalSizeBytes(i int64) {
	m.total_size_bytes = &i
	m.addtotal_size_bytes = nil
}

// TotalSizeBytes returns the value of the "total_size_bytes" field in the mutation.
func (m *GoogleDriveFolderMutation) TotalSizeBytes() (r int64, exists bool) {
	v := m.total_size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalSizeBytes returns the old "total_size_bytes" field's value of the GoogleDriveFolder entity.
// If the GoogleDriveFolder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveFolderMutation) OldTotalSizeBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalSizeBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalSizeBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalSizeBytes: %w", err)
	}
	return oldValue.TotalSizeBytes, nil
}

// AddTotalSizeBytes adds i to the "total_size_bytes" field.
func (m *GoogleDriveFolderMutation) AddTotalSizeBytes(i int64) {
	if m.addtotal_size_bytes != nil {
		*m.addtotal_size_bytes += i
	} else {
		m.addtotal_size_bytes = &i
	}
}

// AddedTotalSizeBytes returns the value that was added to the "total_size_bytes" field in this mutation.
func (m *GoogleDriveFolderMutation) AddedTotalSizeBytes() (r int64, exists bool) {
	v := m.addtotal_size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalSizeBytes resets all changes to the "total_size_bytes" field.
func (m *GoogleDriveFolderMutation) ResetTotalSizeBytes() {
	m.total_size_bytes = nil
	m.addtotal_size_bytes = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GoogleDriveFolderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoogleDriveFolderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoogleDriveFolder entity.
// If the GoogleDriveFolder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveFolderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoogleDriveFolderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoogleDriveFolderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoogleDriveFolderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoogleDriveFolder entity.
// If the GoogleDriveFolder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveFolderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoogleDriveFolderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLastScannedAt sets the "last_scanned_at" field.
func (m *GoogleDriveFolderMutation) SetLastScannedAt(t time.Time) {
	m.last_scanned_at = &t
}

// LastScannedAt returns the value of the "last_scanned_at" field in the mutation.
func (m *GoogleDriveFolderMutation) LastScannedAt() (r time.Time, exists bool) {
	v := m.last_scanned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastScannedAt returns the old "last_scanned_at" field's value of the GoogleDriveFolder entity.
// If the GoogleDriveFolder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveFolderMutation) OldLastScannedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastScannedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastScannedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastScannedAt: %w", err)
	}
	return oldValue.LastScannedAt, nil
}

// ClearLastScannedAt clears the value of the "last_scanned_at" field.
func (m *GoogleDriveFolderMutation) ClearLastScannedAt() {
	m.last_scanned_at = nil
	m.clearedFields[googledrivefolder.FieldLastScannedAt] = struct{}{}
}

// LastScannedAtCleared returns if the "last_scanned_at" field was cleared in this mutation.
func (m *GoogleDriveFolderMutation) LastScannedAtCleared() bool {
	_, ok := m.clearedFields[googledrivefolder.FieldLastScannedAt]
	return ok
}

// ResetLastScannedAt resets all changes to the "last_scanned_at" field.
func (m *GoogleDriveFolderMutation) ResetLastScannedAt() {
	m.last_scanned_at = nil
	delete(m.clearedFields, googledrivefolder.FieldLastScannedAt)
}

// ClearConnection clears the "connection" edge to the GoogleDriveConnection entity.
func (m *GoogleDriveFolderMutation) ClearConnection() {
	m.clearedconnection = true
	m.clearedFields[googledrivefolder.FieldConnectionID] = struct{}{}
}

// ConnectionCleared reports if the "connection" edge to the GoogleDriveConnection entity was cleared.
func (m *GoogleDriveFolderMutation) ConnectionCleared() bool {
	return m.clearedconnection
}

// ConnectionIDs returns the "connection" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectionID instead. It exists only for internal usage by the builders.
func (m *GoogleDriveFolderMutation) ConnectionIDs() (ids []string) {
	if id := m.connection; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnection resets all changes to the "connection" edge.
func (m *GoogleDriveFolderMutation) ResetConnection() {
	m.connection = nil
	m.clearedconnection = false
}

// Where appends a list predicates to the GoogleDriveFolderMutation builder.
func (m *GoogleDriveFolderMutation) Where(ps ...predicate.GoogleDriveFolder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GoogleDriveFolderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GoogleDriveFolderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GoogleDriveFolder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GoogleDriveFolderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GoogleDriveFolderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GoogleDriveFolder).
func (m *GoogleDriveFolderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoogleDriveFolderMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.connection != nil {
		fields = append(fields, googledrivefolder.FieldConnectionID)
	}
	if m.drive_folder_id != nil {
		fields = append(fields, googledrivefolder.FieldDriveFolderID)
	}
	if m.name != nil {
		fields = append(fields, googledrivefolder.FieldName)
	}
	if m._path != nil {
		fields = append(fields, googledrivefolder.FieldPath)
	}
	if m.parent_folder_id != nil {
		fields = append(fields, googledrivefolder.FieldParentFolderID)
	}
	if m.is_root != nil {
		fields = append(fields, googledrivefolder.FieldIsRoot)
	}
	if m.sync_enabled != nil {
		fields = append(fields, googledrivefolder.FieldSyncEnabled)
	}
	if m.sync_direction != nil {
		fields = append(fields, googledrivefolder.FieldSyncDirection)
	}
	if m.file_count != nil {
		fields = append(fields, googledrivefolder.FieldFileCount)
	}
	if m.total_size_bytes != nil {
		fields = append(fields, googledrivefolder.FieldTotalSizeBytes)
	}
	if m.created_at != nil {
		fields = append(fields, googledrivefolder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, googledrivefolder.FieldUpdatedAt)
	}
	if m.last_scanned_at != nil {
		fields = append(fields, googledrivefolder.FieldLastScannedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoogleDriveFolderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case googledrivefolder.FieldConnectionID:
		return m.ConnectionID()
	case googledrivefolder.FieldDriveFolderID:
		return m.DriveFolderID()
	case googledrivefolder.FieldName:
		return m.Name()
	case googledrivefolder.FieldPath:
		return m.Path()
	case googledrivefolder.FieldParentFolderID:
		return m.ParentFolderID()
	case googledrivefolder.FieldIsRoot:
		return m.IsRoot()
	case googledrivefolder.FieldSyncEnabled:
		return m.SyncEnabled()
	case googledrivefolder.FieldSyncDirection:
		return m.SyncDirection()
	case googledrivefolder.FieldFileCount:
		return m.FileCount()
	case googledrivefolder.FieldTotalSizeBytes:
		return m.TotalSizeBytes()
	case googledrivefolder.FieldCreatedAt:
		return m.CreatedAt()
	case googledrivefolder.FieldUpdatedAt:
		return m.UpdatedAt()
	case googledrivefolder.FieldLastScannedAt:
		return m.LastScannedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoogleDriveFolderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case googledrivefolder.FieldConnectionID:
		return m.OldConnectionID(ctx)
	case googledrivefolder.FieldDriveFolderID:
		return m.OldDriveFolderID(ctx)
	case googledrivefolder.FieldName:
		return m.OldName(ctx)
	case googledrivefolder.FieldPath:
		return m.OldPath(ctx)
	case googledrivefolder.FieldParentFolderID:
		return m.OldParentFolderID(ctx)
	case googledrivefolder.FieldIsRoot:
		return m.OldIsRoot(ctx)
	case googledrivefolder.FieldSyncEnabled:
		return m.OldSyncEnabled(ctx)
	case googledrivefolder.FieldSyncDirection:
		return m.OldSyncDirection(ctx)
	case googledrivefolder.FieldFileCount:
		return m.OldFileCount(ctx)
	case googledrivefolder.FieldTotalSizeBytes:
		return m.OldTotalSizeBytes(ctx)
	case googledrivefolder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case googledrivefolder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case googledrivefolder.FieldLastScannedAt:
		return m.OldLastScannedAt(ctx)
	}
	return nil, fmt.Errorf("unknown GoogleDriveFolder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoogleDriveFolderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case googledrivefolder.FieldConnectionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectionID(v)
		return nil
	case googledrivefolder.FieldDriveFolderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDriveFolderID(v)
		return nil
	case googledrivefolder.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case googledrivefolder.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case googledrivefolder.FieldParentFolderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentFolderID(v)
		return nil
	case googledrivefolder.FieldIsRoot:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRoot(v)
		return nil
	case googledrivefolder.FieldSyncEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncEnabled(v)
		return nil
	case googledrivefolder.FieldSyncDirection:
		v, ok := value.(googledrivefolder.SyncDirection)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncDirection(v)
		return nil
	case googledrivefolder.FieldFileCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileCount(v)
		return nil
	case googledrivefolder.FieldTotalSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalSizeBytes(v)
		return nil
	case googledrivefolder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case googledrivefolder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case googledrivefolder.FieldLastScannedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastScannedAt(v)
		return nil
	}
	return fmt.Errorf("unknown GoogleDriveFolder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoogleDriveFolderMutation) AddedFields() []string {
	var fields []string
	if m.addfile_count != nil {
		fields = append(fields, googledrivefolder.FieldFileCount)
	}
	if m.addtotal_size_bytes != nil {
		fields = append(fields, googledrivefolder.FieldTotalSizeBytes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoogleDriveFolderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case googledrivefolder.FieldFileCount:
		return m.AddedFileCount()
	case googledrivefolder.FieldTotalSizeBytes:
		return m.AddedTotalSizeBytes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoogleDriveFolderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case googledrivefolder.FieldFileCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileCount(v)
		return nil
	case googledrivefolder.FieldTotalSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalSizeBytes(v)
		return nil
	}
	return fmt.Errorf("unknown GoogleDriveFolder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoogleDriveFolderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(googledrivefolder.FieldPath) {
		fields = append(fields, googledrivefolder.FieldPath)
	}
	if m.FieldCleared(googledrivefolder.FieldParentFolderID) {
		fields = append(fields, googledrivefolder.FieldParentFolderID)
	}
	if m.FieldCleared(googledrivefolder.FieldLastScannedAt) {
		fields = append(fields, googledrivefolder.FieldLastScannedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoogleDriveFolderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoogleDriveFolderMutation) ClearField(name string) error {
	switch name {
	case googledrivefolder.FieldPath:
		m.ClearPath()
		return nil
	case googledrivefolder.FieldParentFolderID:
		m.ClearParentFolderID()
		return nil
	case googledrivefolder.FieldLastScannedAt:
		m.ClearLastScannedAt()
		return nil
	}
	return fmt.Errorf("unknown GoogleDriveFolder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoogleDriveFolderMutation) ResetField(name string) error {
	switch name {
	case googledrivefolder.FieldConnectionID:
		m.ResetConnectionID()
		return nil
	case googledrivefolder.FieldDriveFolderID:
		m.ResetDriveFolderID()
		return nil
	case googledrivefolder.FieldName:
		m.ResetName()
		return nil
	case googledrivefolder.FieldPath:
		m.ResetPath()
		return nil
	case googledrivefolder.FieldParentFolderID:
		m.ResetParentFolderID()
		return nil
	case googledrivefolder.FieldIsRoot:
		m.ResetIsRoot()
		return nil
	case googledrivefolder.FieldSyncEnabled:
		m.ResetSyncEnabled()
		return nil
	case googledrivefolder.FieldSyncDirection:
		m.ResetSyncDirection()
		return nil
	case googledrivefolder.FieldFileCount:
		m.ResetFileCount()
		return nil
	case googledrivefolder.FieldTotalSizeBytes:
		m.ResetTotalSizeBytes()
		return nil
	case googledrivefolder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case googledrivefolder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case googledrivefolder.FieldLastScannedAt:
		m.ResetLastScannedAt()
		return nil
	}
	return fmt.Errorf("unknown GoogleDriveFolder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoogleDriveFolderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.connection != nil {
		edges = append(edges, googledrivefolder.EdgeConnection)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoogleDriveFolderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case googledrivefolder.EdgeConnection:
		if id := m.connection; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoogleDriveFolderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoogleDriveFolderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoogleDriveFolderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedconnection {
		edges = append(edges, googledrivefolder.EdgeConnection)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoogleDriveFolderMutation) EdgeCleared(name string) bool {
	switch name {
	case googledrivefolder.EdgeConnection:
		return m.clearedconnection
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoogleDriveFolderMutation) ClearEdge(name string) error {
	switch name {
	case googledrivefolder.EdgeConnection:
		m.ClearConnection()
		return nil
	}
	return fmt.Errorf("unknown GoogleDriveFolder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoogleDriveFolderMutation) ResetEdge(name string) error {
	switch name {
	case googledrivefolder.EdgeConnection:
		m.ResetConnection()
		return nil
	}
	return fmt.Errorf("unknown GoogleDriveFolder edge %s", name)
}

// GoogleDriveSyncMutation represents an operation that mutates the GoogleDriveSync nodes in the graph.
type GoogleDriveSyncMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	folder_id            *string
	sync_type            *googledrivesync.SyncType
	status               *googledrivesync.Status
	started_at           *time.Time
	completed_at         *time.Time
	files_scanned        *int
	addfiles_scanned     *int
	files_downloaded     *int
	addfiles_downloaded  *int
	files_uploaded       *int
	addfiles_uploaded    *int
	files_deleted        *int
	addfiles_deleted     *int
	files_failed         *int
	addfiles_failed      *int
	bytes_transferred    *int64
	addbytes_transferred *int64
	error_message        *string
	error_details        *map[string]interface{}
	change_token         *string
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	connection           *string
	clearedconnection    bool
	done                 bool
	oldValue             func(context.Context) (*GoogleDriveSync, error)
	predicates           []predicate.GoogleDriveSync
}

var _ ent.Mutation = (*GoogleDriveSyncMutation)(nil)

// googledrivesyncOption allows management of the mutation configuration using functional options.
type googledrivesyncOption func(*GoogleDriveSyncMutation)

// newGoogleDriveSyncMutation creates new mutation for the GoogleDriveSync entity.
func newGoogleDriveSyncMutation(c config, op Op, opts ...googledrivesyncOption) *GoogleDriveSyncMutation {
	m := &GoogleDriveSyncMutation{
		config:        c,
		op:            op,
		typ:           TypeGoogleDriveSync,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoogleDriveSyncID sets the ID field of the mutation.
func withGoogleDriveSyncID(id string) googledrivesyncOption {
	return func(m *GoogleDriveSyncMutation) {
		var (
			err   error
			once  sync.Once
			value *GoogleDriveSync
		)
		m.oldValue = func(ctx context.Context) (*GoogleDriveSync, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoogleDriveSync.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoogleDriveSync sets the old GoogleDriveSync of the mutation.
func withGoogleDriveSync(node *GoogleDriveSync) googledrivesyncOption {
	return func(m *GoogleDriveSyncMutation) {
		m.oldValue = func(context.Context) (*GoogleDriveSync, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoogleDriveSyncMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoogleDriveSyncMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GoogleDriveSync entities.
func (m *GoogleDriveSyncMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoogleDriveSyncMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoogleDriveSyncMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoogleDriveSync.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetConnectionID sets the "connection_id" field.
func (m *GoogleDriveSyncMutation) SetConnectionID(s string) {
	m.connection = &s
}

// ConnectionID returns the value of the "connection_id" field in the mutation.
func (m *GoogleDriveSyncMutation) ConnectionID() (r string, exists bool) {
	v := m.connection
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectionID returns the old "connection_id" field's value of the GoogleDriveSync entity.
// If the GoogleDriveSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveSyncMutation) OldConnectionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectionID: %w", err)
	}
	return oldValue.ConnectionID, nil
}

// ResetConnectionID resets all changes to the "connection_id" field.
func (m *GoogleDriveSyncMutation) ResetConnectionID() {
	m.connection = nil
}

// SetFolderID sets the "folder_id" field.
func (m *GoogleDriveSyncMutation) SetFolderID(s string) {
	m.folder_id = &s
}

// FolderID returns the value of the "folder_id" field in the mutation.
func (m *GoogleDriveSyncMutation) FolderID() (r string, exists bool) {
	v := m.folder_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFolderID returns the old "folder_id" field's value of the GoogleDriveSync entity.
// If the GoogleDriveSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveSyncMutation) OldFolderID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFolderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFolderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFolderID: %w", err)
	}
	return oldValue.FolderID, nil
}

// ClearFolderID clears the value of the "folder_id" field.
func (m *GoogleDriveSyncMutation) ClearFolderID() {
	m.folder_id = nil
	m.clearedFields[googledrivesync.FieldFolderID] = struct{}{}
}

// FolderIDCleared returns if the "folder_id" field was cleared in this mutation.
func (m *GoogleDriveSyncMutation) FolderIDCleared() bool {
	_, ok := m.clearedFields[googledrivesync.FieldFolderID]
	return ok
}

// ResetFolderID resets all changes to the "folder_id" field.
func (m *GoogleDriveSyncMutation) ResetFolderID() {
	m.folder_id = nil
	delete(m.clearedFields, googledrivesync.FieldFolderID)
}

// SetSyncType sets the "sync_type" field.
func (m *GoogleDriveSyncMutation) SetSyncType(gt googledrivesync.SyncType) {
	m.sync_type = &gt
}

// SyncType returns the value of the "sync_type" field in the mutation.
func (m *GoogleDriveSyncMutation) SyncType() (r googledrivesync.SyncType, exists bool) {
	v := m.sync_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncType returns the old "sync_type" field's value of the GoogleDriveSync entity.
// If the GoogleDriveSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveSyncMutation) OldSyncType(ctx context.Context) (v googledrivesync.SyncType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncType: %w", err)
	}
	return oldValue.SyncType, nil
}

// ResetSyncType resets all changes to the "sync_type" field.
func (m *GoogleDriveSyncMutation) ResetSyncType() {
	m.sync_type = nil
}

// SetStatus sets the "status" field.
func (m *GoogleDriveSyncMutation) SetStatus(_go googledrivesync.Status) {
	m.status = &_go
}

// Status returns the value of the "status" field in the mutation.
func (m *GoogleDriveSyncMutation) Status() (r googledrivesync.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the GoogleDriveSync entity.
// If the GoogleDriveSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveSyncMutation) OldStatus(ctx context.Context) (v googledrivesync.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *GoogleDriveSyncMutation) ResetStatus() {
	m.status = nil
}

// SetStartedAt sets the "started_at" field.
func (m *GoogleDriveSyncMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *GoogleDriveSyncMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the GoogleDriveSync entity.
// If the GoogleDriveSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveSyncMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *GoogleDriveSyncMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[googledrivesync.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *GoogleDriveSyncMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[googledrivesync.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *GoogleDriveSyncMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, googledrivesync.FieldStartedAt)
}

// SetCompletedAt sets the "completed_at" field.
func (m *GoogleDriveSyncMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *GoogleDriveSyncMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the GoogleDriveSync entity.
// If the GoogleDriveSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveSyncMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *GoogleDriveSyncMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[googledrivesync.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *GoogleDriveSyncMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[googledrivesync.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *GoogleDriveSyncMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, googledrivesync.FieldCompletedAt)
}

// SetFilesScanned sets the "files_scanned" field.
func (m *GoogleDriveSyncMutation) SetFilesScanned(i int) {
	m.files_scanned = &i
	m.addfiles_scanned = nil
}

// FilesScanned returns the value of the "files_scanned" field in the mutation.
func (m *GoogleDriveSyncMutation) FilesScanned() (r int, exists bool) {
	v := m.files_scanned
	if v == nil {
		return
	}
	return *v, true
}

// OldFilesScanned returns the old "files_scanned" field's value of the GoogleDriveSync entity.
// If the GoogleDriveSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveSyncMutation) OldFilesScanned(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilesScanned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilesScanned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilesScanned: %w", err)
	}
	return oldValue.FilesScanned, nil
}

// AddFilesScanned adds i to the "files_scanned" field.
func (m *GoogleDriveSyncMutation) AddFilesScanned(i int) {
	if m.addfiles_scanned != nil {
		*m.addfiles_scanned += i
	} else {
		m.addfiles_scanned = &i
	}
}

// AddedFilesScanned returns the value that was added to the "files_scanned" field in this mutation.
func (m *GoogleDriveSyncMutation) AddedFilesScanned() (r int, exists bool) {
	v := m.addfiles_scanned
	if v == nil {
		return
	}
	return *v, true
}

// ResetFilesScanned resets all changes to the "files_scanned" field.
func (m *GoogleDriveSyncMutation) ResetFilesScanned() {
	m.files_scanned = nil
	m.addfiles_scanned = nil
}

// SetFilesDownloaded sets the "files_downloaded" field.
func (m *GoogleDriveSyncMutation) SetFilesDownloaded(i int) {
	m.files_downloaded = &i
	m.addfiles_downloaded = nil
}

// FilesDownloaded returns the value of the "files_downloaded" field in the mutation.
func (m *GoogleDriveSyncMutation) FilesDownloaded() (r int, exists bool) {
	v := m.files_downloaded
	if v == nil {
		return
	}
	return *v, true
}

// OldFilesDownloaded returns the old "files_downloaded" field's value of the GoogleDriveSync entity.
// If the GoogleDriveSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveSyncMutation) OldFilesDownloaded(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilesDownloaded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilesDownloaded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilesDownloaded: %w", err)
	}
	return oldValue.FilesDownloaded, nil
}

// AddFilesDownloaded adds i to the "files_downloaded" field.
func (m *GoogleDriveSyncMutation) AddFilesDownloaded(i int) {
	if m.addfiles_downloaded != nil {
		*m.addfiles_downloaded += i
	} else {
		m.addfiles_downloaded = &i
	}
}

// AddedFilesDownloaded returns the value that was added to the "files_downloaded" field in this mutation.
func (m *GoogleDriveSyncMutation) AddedFilesDownloaded() (r int, exists bool) {
	v := m.addfiles_downloaded
	if v == nil {
		return
	}
	return *v, true
}

// ResetFilesDownloaded resets all changes to the "files_downloaded" field.
func (m *GoogleDriveSyncMutation) ResetFilesDownloaded() {
	m.files_downloaded = nil
	m.addfiles_downloaded = nil
}

// SetFilesUploaded sets the "files_uploaded" field.
func (m *GoogleDriveSyncMutation) SetFilesUploaded(i int) {
	m.files_uploaded = &i
	m.addfiles_uploaded = nil
}

// FilesUploaded returns the value of the "files_uploaded" field in the mutation.
func (m *GoogleDriveSyncMutation) FilesUploaded() (r int, exists bool) {
	v := m.files_uploaded
	if v == nil {
		return
	}
	return *v, true
}

// OldFilesUploaded returns the old "files_uploaded" field's value of the GoogleDriveSync entity.
// If the GoogleDriveSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveSyncMutation) OldFilesUploaded(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilesUploaded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilesUploaded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilesUploaded: %w", err)
	}
	return oldValue.FilesUploaded, nil
}

// AddFilesUploaded adds i to the "files_uploaded" field.
func (m *GoogleDriveSyncMutation) AddFilesUploaded(i int) {
	if m.addfiles_uploaded != nil {
		*m.addfiles_uploaded += i
	} else {
		m.addfiles_uploaded = &i
	}
}

// AddedFilesUploaded returns the value that was added to the "files_uploaded" field in this mutation.
func (m *GoogleDriveSyncMutation) AddedFilesUploaded() (r int, exists bool) {
	v := m.addfiles_uploaded
	if v == nil {
		return
	}
	return *v, true
}

// ResetFilesUploaded resets all changes to the "files_uploaded" field.
func (m *GoogleDriveSyncMutation) ResetFilesUploaded() {
	m.files_uploaded = nil
	m.addfiles_uploaded = nil
}

// SetFilesDeleted sets the "files_deleted" field.
func (m *GoogleDriveSyncMutation) SetFilesDeleted(i int) {
	m.files_deleted = &i
	m.addfiles_deleted = nil
}

// FilesDeleted returns the value of the "files_deleted" field in the mutation.
func (m *GoogleDriveSyncMutation) FilesDeleted() (r int, exists bool) {
	v := m.files_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldFilesDeleted returns the old "files_deleted" field's value of the GoogleDriveSync entity.
// If the GoogleDriveSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveSyncMutation) OldFilesDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilesDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilesDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilesDeleted: %w", err)
	}
	return oldValue.FilesDeleted, nil
}

// AddFilesDeleted adds i to the "files_deleted" field.
func (m *GoogleDriveSyncMutation) AddFilesDeleted(i int) {
	if m.addfiles_deleted != nil {
		*m.addfiles_deleted += i
	} else {
		m.addfiles_deleted = &i
	}
}

// AddedFilesDeleted returns the value that was added to the "files_deleted" field in this mutation.
func (m *GoogleDriveSyncMutation) AddedFilesDeleted() (r int, exists bool) {
	v := m.addfiles_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetFilesDeleted resets all changes to the "files_deleted" field.
func (m *GoogleDriveSyncMutation) ResetFilesDeleted() {
	m.files_deleted = nil
	m.addfiles_deleted = nil
}

// SetFilesFailed sets the "files_failed" field.
func (m *GoogleDriveSyncMutation) SetFilesFailed(i int) {
	m.files_failed = &i
	m.addfiles_failed = nil
}

// FilesFailed returns the value of the "files_failed" field in the mutation.
func (m *GoogleDriveSyncMutation) FilesFailed() (r int, exists bool) {
	v := m.files_failed
	if v == nil {
		return
	}
	return *v, true
}

// OldFilesFailed returns the old "files_failed" field's value of the GoogleDriveSync entity.
// If the GoogleDriveSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveSyncMutation) OldFilesFailed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilesFailed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilesFailed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilesFailed: %w", err)
	}
	return oldValue.FilesFailed, nil
}

// AddFilesFailed adds i to the "files_failed" field.
func (m *GoogleDriveSyncMutation) AddFilesFailed(i int) {
	if m.addfiles_failed != nil {
		*m.addfiles_failed += i
	} else {
		m.addfiles_failed = &i
	}
}

// AddedFilesFailed returns the value that was added to the "files_failed" field in this mutation.
func (m *GoogleDriveSyncMutation) AddedFilesFailed() (r int, exists bool) {
	v := m.addfiles_failed
	if v == nil {
		return
	}
	return *v, true
}

// ResetFilesFailed resets all changes to the "files_failed" field.
func (m *GoogleDriveSyncMutation) ResetFilesFailed() {
	m.files_failed = nil
	m.addfiles_failed = nil
}

// SetBytesTransferred sets the "bytes_transferred" field.
func (m *GoogleDriveSyncMutation) SetBytesTransferred(i int64) {
	m.bytes_transferred = &i
	m.addbytes_transferred = nil
}

// BytesTransferred returns the value of the "bytes_transferred" field in the mutation.
func (m *GoogleDriveSyncMutation) BytesTransferred() (r int64, exists bool) {
	v := m.bytes_transferred
	if v == nil {
		return
	}
	return *v, true
}

// OldBytesTransferred returns the old "bytes_transferred" field's value of the GoogleDriveSync entity.
// If the GoogleDriveSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveSyncMutation) OldBytesTransferred(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBytesTransferred is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBytesTransferred requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBytesTransferred: %w", err)
	}
	return oldValue.BytesTransferred, nil
}

// AddBytesTransferred adds i to the "bytes_transferred" field.
func (m *GoogleDriveSyncMutation) AddBytesTransferred(i int64) {
	if m.addbytes_transferred != nil {
		*m.addbytes_transferred += i
	} else {
		m.addbytes_transferred = &i
	}
}

// AddedBytesTransferred returns the value that was added to the "bytes_transferred" field in this mutation.
func (m *GoogleDriveSyncMutation) AddedBytesTransferred() (r int64, exists bool) {
	v := m.addbytes_transferred
	if v == nil {
		return
	}
	return *v, true
}

// ResetBytesTransferred resets all changes to the "bytes_transferred" field.
func (m *GoogleDriveSyncMutation) ResetBytesTransferred() {
	m.bytes_transferred = nil
	m.addbytes_transferred = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *GoogleDriveSyncMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *GoogleDriveSyncMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the GoogleDriveSync entity.
// If the GoogleDriveSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveSyncMutation) OldErrorMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *GoogleDriveSyncMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[googledrivesync.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *GoogleDriveSyncMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[googledrivesync.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *GoogleDriveSyncMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, googledrivesync.FieldErrorMessage)
}

// SetErrorDetails sets the "error_details" field.
func (m *GoogleDriveSyncMutation) SetErrorDetails(value map[string]interface{}) {
	m.error_details = &value
}

// ErrorDetails returns the value of the "error_details" field in the mutation.
func (m *GoogleDriveSyncMutation) ErrorDetails() (r map[string]interface{}, exists bool) {
	v := m.error_details
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorDetails returns the old "error_details" field's value of the GoogleDriveSync entity.
// If the GoogleDriveSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveSyncMutation) OldErrorDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorDetails: %w", err)
	}
	return oldValue.ErrorDetails, nil
}

// ClearErrorDetails clears the value of the "error_details" field.
func (m *GoogleDriveSyncMutation) ClearErrorDetails() {
	m.error_details = nil
	m.clearedFields[googledrivesync.FieldErrorDetails] = struct{}{}
}

// ErrorDetailsCleared returns if the "error_details" field was cleared in this mutation.
func (m *GoogleDriveSyncMutation) ErrorDetailsCleared() bool {
	_, ok := m.clearedFields[googledrivesync.FieldErrorDetails]
	return ok
}

// ResetErrorDetails resets all changes to the "error_details" field.
func (m *GoogleDriveSyncMutation) ResetErrorDetails() {
	m.error_details = nil
	delete(m.clearedFields, googledrivesync.FieldErrorDetails)
}

// SetChangeToken sets the "change_token" field.
func (m *GoogleDriveSyncMutation) SetChangeToken(s string) {
	m.change_token = &s
}

// ChangeToken returns the value of the "change_token" field in the mutation.
func (m *GoogleDriveSyncMutation) ChangeToken() (r string, exists bool) {
	v := m.change_token
	if v == nil {
		return
	}
	return *v, true
}

// OldChangeToken returns the old "change_token" field's value of the GoogleDriveSync entity.
// If the GoogleDriveSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveSyncMutation) OldChangeToken(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChangeToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChangeToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangeToken: %w", err)
	}
	return oldValue.ChangeToken, nil
}

// ClearChangeToken clears the value of the "change_token" field.
func (m *GoogleDriveSyncMutation) ClearChangeToken() {
	m.change_token = nil
	m.clearedFields[googledrivesync.FieldChangeToken] = struct{}{}
}

// ChangeTokenCleared returns if the "change_token" field was cleared in this mutation.
func (m *GoogleDriveSyncMutation) ChangeTokenCleared() bool {
	_, ok := m.clearedFields[googledrivesync.FieldChangeToken]
	return ok
}

// ResetChangeToken resets all changes to the "change_token" field.
func (m *GoogleDriveSyncMutation) ResetChangeToken() {
	m.change_token = nil
	delete(m.clearedFields, googledrivesync.FieldChangeToken)
}

// SetCreatedAt sets the "created_at" field.
func (m *GoogleDriveSyncMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoogleDriveSyncMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoogleDriveSync entity.
// If the GoogleDriveSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveSyncMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoogleDriveSyncMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoogleDriveSyncMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoogleDriveSyncMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoogleDriveSync entity.
// If the GoogleDriveSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleDriveSyncMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoogleDriveSyncMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearConnection clears the "connection" edge to the GoogleDriveConnection entity.
func (m *GoogleDriveSyncMutation) ClearConnection() {
	m.clearedconnection = true
	m.clearedFields[googledrivesync.FieldConnectionID] = struct{}{}
}

// ConnectionCleared reports if the "connection" edge to the GoogleDriveConnection entity was cleared.
func (m *GoogleDriveSyncMutation) ConnectionCleared() bool {
	return m.clearedconnection
}

// ConnectionIDs returns the "connection" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectionID instead. It exists only for internal usage by the builders.
func (m *GoogleDriveSyncMutation) ConnectionIDs() (ids []string) {
	if id := m.connection; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnection resets all changes to the "connection" edge.
func (m *GoogleDriveSyncMutation) ResetConnection() {
	m.connection = nil
	m.clearedconnection = false
}

// Where appends a list predicates to the GoogleDriveSyncMutation builder.
func (m *GoogleDriveSyncMutation) Where(ps ...predicate.GoogleDriveSync) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GoogleDriveSyncMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GoogleDriveSyncMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GoogleDriveSync, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GoogleDriveSyncMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GoogleDriveSyncMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GoogleDriveSync).
func (m *GoogleDriveSyncMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoogleDriveSyncMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.connection != nil {
		fields = append(fields, googledrivesync.FieldConnectionID)
	}
	if m.folder_id != nil {
		fields = append(fields, googledrivesync.FieldFolderID)
	}
	if m.sync_type != nil {
		fields = append(fields, googledrivesync.FieldSyncType)
	}
	if m.status != nil {
		fields = append(fields, googledrivesync.FieldStatus)
	}
	if m.started_at != nil {
		fields = append(fields, googledrivesync.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, googledrivesync.FieldCompletedAt)
	}
	if m.files_scanned != nil {
		fields = append(fields, googledrivesync.FieldFilesScanned)
	}
	if m.files_downloaded != nil {
		fields = append(fields, googledrivesync.FieldFilesDownloaded)
	}
	if m.files_uploaded != nil {
		fields = append(fields, googledrivesync.FieldFilesUploaded)
	}
	if m.files_deleted != nil {
		fields = append(fields, googledrivesync.FieldFilesDeleted)
	}
	if m.files_failed != nil {
		fields = append(fields, googledrivesync.FieldFilesFailed)
	}
	if m.bytes_transferred != nil {
		fields = append(fields, googledrivesync.FieldBytesTransferred)
	}
	if m.error_message != nil {
		fields = append(fields, googledrivesync.FieldErrorMessage)
	}
	if m.error_details != nil {
		fields = append(fields, googledrivesync.FieldErrorDetails)
	}
	if m.change_token != nil {
		fields = append(fields, googledrivesync.FieldChangeToken)
	}
	if m.created_at != nil {
		fields = append(fields, googledrivesync.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, googledrivesync.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoogleDriveSyncMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case googledrivesync.FieldConnectionID:
		return m.ConnectionID()
	case googledrivesync.FieldFolderID:
		return m.FolderID()
	case googledrivesync.FieldSyncType:
		return m.SyncType()
	case googledrivesync.FieldStatus:
		return m.Status()
	case googledrivesync.FieldStartedAt:
		return m.StartedAt()
	case googledrivesync.FieldCompletedAt:
		return m.CompletedAt()
	case googledrivesync.FieldFilesScanned:
		return m.FilesScanned()
	case googledrivesync.FieldFilesDownloaded:
		return m.FilesDownloaded()
	case googledrivesync.FieldFilesUploaded:
		return m.FilesUploaded()
	case googledrivesync.FieldFilesDeleted:
		return m.FilesDeleted()
	case googledrivesync.FieldFilesFailed:
		return m.FilesFailed()
	case googledrivesync.FieldBytesTransferred:
		return m.BytesTransferred()
	case googledrivesync.FieldErrorMessage:
		return m.ErrorMessage()
	case googledrivesync.FieldErrorDetails:
		return m.ErrorDetails()
	case googledrivesync.FieldChangeToken:
		return m.ChangeToken()
	case googledrivesync.FieldCreatedAt:
		return m.CreatedAt()
	case googledrivesync.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoogleDriveSyncMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case googledrivesync.FieldConnectionID:
		return m.OldConnectionID(ctx)
	case googledrivesync.FieldFolderID:
		return m.OldFolderID(ctx)
	case googledrivesync.FieldSyncType:
		return m.OldSyncType(ctx)
	case googledrivesync.FieldStatus:
		return m.OldStatus(ctx)
	case googledrivesync.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case googledrivesync.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case googledrivesync.FieldFilesScanned:
		return m.OldFilesScanned(ctx)
	case googledrivesync.FieldFilesDownloaded:
		return m.OldFilesDownloaded(ctx)
	case googledrivesync.FieldFilesUploaded:
		return m.OldFilesUploaded(ctx)
	case googledrivesync.FieldFilesDeleted:
		return m.OldFilesDeleted(ctx)
	case googledrivesync.FieldFilesFailed:
		return m.OldFilesFailed(ctx)
	case googledrivesync.FieldBytesTransferred:
		return m.OldBytesTransferred(ctx)
	case googledrivesync.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case googledrivesync.FieldErrorDetails:
		return m.OldErrorDetails(ctx)
	case googledrivesync.FieldChangeToken:
		return m.OldChangeToken(ctx)
	case googledrivesync.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case googledrivesync.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown GoogleDriveSync field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoogleDriveSyncMutation) SetField(name string, value ent.Value) error {
	switch name {
	case googledrivesync.FieldConnectionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectionID(v)
		return nil
	case googledrivesync.FieldFolderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFolderID(v)
		return nil
	case googledrivesync.FieldSyncType:
		v, ok := value.(googledrivesync.SyncType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncType(v)
		return nil
	case googledrivesync.FieldStatus:
		v, ok := value.(googledrivesync.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case googledrivesync.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case googledrivesync.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case googledrivesync.FieldFilesScanned:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilesScanned(v)
		return nil
	case googledrivesync.FieldFilesDownloaded:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilesDownloaded(v)
		return nil
	case googledrivesync.FieldFilesUploaded:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilesUploaded(v)
		return nil
	case googledrivesync.FieldFilesDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilesDeleted(v)
		return nil
	case googledrivesync.FieldFilesFailed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilesFailed(v)
		return nil
	case googledrivesync.FieldBytesTransferred:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBytesTransferred(v)
		return nil
	case googledrivesync.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case googledrivesync.FieldErrorDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorDetails(v)
		return nil
	case googledrivesync.FieldChangeToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangeToken(v)
		return nil
	case googledrivesync.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case googledrivesync.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown GoogleDriveSync field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoogleDriveSyncMutation) AddedFields() []string {
	var fields []string
	if m.addfiles_scanned != nil {
		fields = append(fields, googledrivesync.FieldFilesScanned)
	}
	if m.addfiles_downloaded != nil {
		fields = append(fields, googledrivesync.FieldFilesDownloaded)
	}
	if m.addfiles_uploaded != nil {
		fields = append(fields, googledrivesync.FieldFilesUploaded)
	}
	if m.addfiles_deleted != nil {
		fields = append(fields, googledrivesync.FieldFilesDeleted)
	}
	if m.addfiles_failed != nil {
		fields = append(fields, googledrivesync.FieldFilesFailed)
	}
	if m.addbytes_transferred != nil {
		fields = append(fields, googledrivesync.FieldBytesTransferred)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoogleDriveSyncMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case googledrivesync.FieldFilesScanned:
		return m.AddedFilesScanned()
	case googledrivesync.FieldFilesDownloaded:
		return m.AddedFilesDownloaded()
	case googledrivesync.FieldFilesUploaded:
		return m.AddedFilesUploaded()
	case googledrivesync.FieldFilesDeleted:
		return m.AddedFilesDeleted()
	case googledrivesync.FieldFilesFailed:
		return m.AddedFilesFailed()
	case googledrivesync.FieldBytesTransferred:
		return m.AddedBytesTransferred()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoogleDriveSyncMutation) AddField(name string, value ent.Value) error {
	switch name {
	case googledrivesync.FieldFilesScanned:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFilesScanned(v)
		return nil
	case googledrivesync.FieldFilesDownloaded:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFilesDownloaded(v)
		return nil
	case googledrivesync.FieldFilesUploaded:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFilesUploaded(v)
		return nil
	case googledrivesync.FieldFilesDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFilesDeleted(v)
		return nil
	case googledrivesync.FieldFilesFailed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFilesFailed(v)
		return nil
	case googledrivesync.FieldBytesTransferred:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBytesTransferred(v)
		return nil
	}
	return fmt.Errorf("unknown GoogleDriveSync numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoogleDriveSyncMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(googledrivesync.FieldFolderID) {
		fields = append(fields, googledrivesync.FieldFolderID)
	}
	if m.FieldCleared(googledrivesync.FieldStartedAt) {
		fields = append(fields, googledrivesync.FieldStartedAt)
	}
	if m.FieldCleared(googledrivesync.FieldCompletedAt) {
		fields = append(fields, googledrivesync.FieldCompletedAt)
	}
	if m.FieldCleared(googledrivesync.FieldErrorMessage) {
		fields = append(fields, googledrivesync.FieldErrorMessage)
	}
	if m.FieldCleared(googledrivesync.FieldErrorDetails) {
		fields = append(fields, googledrivesync.FieldErrorDetails)
	}
	if m.FieldCleared(googledrivesync.FieldChangeToken) {
		fields = append(fields, googledrivesync.FieldChangeToken)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoogleDriveSyncMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoogleDriveSyncMutation) ClearField(name string) error {
	switch name {
	case googledrivesync.FieldFolderID:
		m.ClearFolderID()
		return nil
	case googledrivesync.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case googledrivesync.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case googledrivesync.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case googledrivesync.FieldErrorDetails:
		m.ClearErrorDetails()
		return nil
	case googledrivesync.FieldChangeToken:
		m.ClearChangeToken()
		return nil
	}
	return fmt.Errorf("unknown GoogleDriveSync nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoogleDriveSyncMutation) ResetField(name string) error {
	switch name {
	case googledrivesync.FieldConnectionID:
		m.ResetConnectionID()
		return nil
	case googledrivesync.FieldFolderID:
		m.ResetFolderID()
		return nil
	case googledrivesync.FieldSyncType:
		m.ResetSyncType()
		return nil
	case googledrivesync.FieldStatus:
		m.ResetStatus()
		return nil
	case googledrivesync.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case googledrivesync.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case googledrivesync.FieldFilesScanned:
		m.ResetFilesScanned()
		return nil
	case googledrivesync.FieldFilesDownloaded:
		m.ResetFilesDownloaded()
		return nil
	case googledrivesync.FieldFilesUploaded:
		m.ResetFilesUploaded()
		return nil
	case googledrivesync.FieldFilesDeleted:
		m.ResetFilesDeleted()
		return nil
	case googledrivesync.FieldFilesFailed:
		m.ResetFilesFailed()
		return nil
	case googledrivesync.FieldBytesTransferred:
		m.ResetBytesTransferred()
		return nil
	case googledrivesync.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case googledrivesync.FieldErrorDetails:
		m.ResetErrorDetails()
		return nil
	case googledrivesync.FieldChangeToken:
		m.ResetChangeToken()
		return nil
	case googledrivesync.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case googledrivesync.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown GoogleDriveSync field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoogleDriveSyncMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.connection != nil {
		edges = append(edges, googledrivesync.EdgeConnection)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoogleDriveSyncMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case googledrivesync.EdgeConnection:
		if id := m.connection; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoogleDriveSyncMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoogleDriveSyncMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoogleDriveSyncMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedconnection {
		edges = append(edges, googledrivesync.EdgeConnection)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoogleDriveSyncMutation) EdgeCleared(name string) bool {
	switch name {
	case googledrivesync.EdgeConnection:
		return m.clearedconnection
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoogleDriveSyncMutation) ClearEdge(name string) error {
	switch name {
	case googledrivesync.EdgeConnection:
		m.ClearConnection()
		return nil
	}
	return fmt.Errorf("unknown GoogleDriveSync unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoogleDriveSyncMutation) ResetEdge(name string) error {
	switch name {
	case googledrivesync.EdgeConnection:
		m.ResetConnection()
		return nil
	}
	return fmt.Errorf("unknown GoogleDriveSync edge %s", name)
}

// LineItemMutation represents an operation that mutates the LineItem nodes in the graph.
type LineItemMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	line_number          *int
	addline_number       *int
	description          *string
	sku                  *string
	product_code         *string
	quantity             *float64
	addquantity          *float64
	unit                 *string
	unit_price           *float64
	addunit_price        *float64
	total_price          *float64
	addtotal_price       *float64
	discount_amount      *float64
	adddiscount_amount   *float64
	discount_description *string
	tax_amount           *float64
	addtax_amount        *float64
	tax_rate             *float64
	addtax_rate          *float64
	is_taxable           *bool
	category             *string
	tags                 *[]string
	appendtags           []string
	metadata             *map[string]interface{}
	legacy_id            *string
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	receipt              *string
	clearedreceipt       bool
	done                 bool
	oldValue             func(context.Context) (*LineItem, error)
	predicates           []predicate.LineItem
}

var _ ent.Mutation = (*LineItemMutation)(nil)

// lineitemOption allows management of the mutation configuration using functional options.
type lineitemOption func(*LineItemMutation)

// newLineItemMutation creates new mutation for the LineItem entity.
func newLineItemMutation(c config, op Op, opts ...lineitemOption) *LineItemMutation {
	m := &LineItemMutation{
		config:        c,
		op:            op,
		typ:           TypeLineItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLineItemID sets the ID field of the mutation.
func withLineItemID(id string) lineitemOption {
	return func(m *LineItemMutation) {
		var (
			err   error
			once  sync.Once
			value *LineItem
		)
		m.oldValue = func(ctx context.Context) (*LineItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LineItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLineItem sets the old LineItem of the mutation.
func withLineItem(node *LineItem) lineitemOption {
	return func(m *LineItemMutation) {
		m.oldValue = func(context.Context) (*LineItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LineItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LineItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LineItem entities.
func (m *LineItemMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LineItemMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LineItemMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LineItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReceiptID sets the "receipt_id" field.
func (m *LineItemMutation) SetReceiptID(s string) {
	m.receipt = &s
}

// ReceiptID returns the value of the "receipt_id" field in the mutation.
func (m *LineItemMutation) ReceiptID() (r string, exists bool) {
	v := m.receipt
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiptID returns the old "receipt_id" field's value of the LineItem entity.
// If the LineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LineItemMutation) OldReceiptID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiptID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiptID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiptID: %w", err)
	}
	return oldValue.ReceiptID, nil
}

// ResetReceiptID resets all changes to the "receipt_id" field.
func (m *LineItemMutation) ResetReceiptID() {
	m.receipt = nil
}

// SetLineNumber sets the "line_number" field.
func (m *LineItemMutation) SetLineNumber(i int) {
	m.line_number = &i
	m.addline_number = nil
}

// LineNumber returns the value of the "line_number" field in the mutation.
func (m *LineItemMutation) LineNumber() (r int, exists bool) {
	v := m.line_number
	if v == nil {
		return
	}
	return *v, true
}

// OldLineNumber returns the old "line_number" field's value of the LineItem entity.
// If the LineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LineItemMutation) OldLineNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLineNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLineNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLineNumber: %w", err)
	}
	return oldValue.LineNumber, nil
}

// AddLineNumber adds i to the "line_number" field.
func (m *LineItemMutation) AddLineNumber(i int) {
	if m.addline_number != nil {
		*m.addline_number += i
	} else {
		m.addline_number = &i
	}
}

// AddedLineNumber returns the value that was added to the "line_number" field in this mutation.
func (m *LineItemMutation) AddedLineNumber() (r int, exists bool) {
	v := m.addline_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetLineNumber resets all changes to the "line_number" field.
func (m *LineItemMutation) ResetLineNumber() {
	m.line_number = nil
	m.addline_number = nil
}

// SetDescription sets the "description" field.
func (m *LineItemMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LineItemMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the LineItem entity.
// If the LineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LineItemMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *LineItemMutation) ResetDescription() {
	m.description = nil
}

// SetSku sets the "sku" field.
func (m *LineItemMutation) SetSku(s string) {
	m.sku = &s
}

// Sku returns the value of the "sku" field in the mutation.
func (m *LineItemMutation) Sku() (r string, exists bool) {
	v := m.sku
	if v == nil {
		return
	}
	return *v, true
}

// OldSku returns the old "sku" field's value of the LineItem entity.
// If the LineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LineItemMutation) OldSku(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSku is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSku requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSku: %w", err)
	}
	return oldValue.Sku, nil
}

// ClearSku clears the value of the "sku" field.
func (m *LineItemMutation) ClearSku() {
	m.sku = nil
	m.clearedFields[lineitem.FieldSku] = struct{}{}
}

// SkuCleared returns if the "sku" field was cleared in this mutation.
func (m *LineItemMutation) SkuCleared() bool {
	_, ok := m.clearedFields[lineitem.FieldSku]
	return ok
}

// ResetSku resets all changes to the "sku" field.
func (m *LineItemMutation) ResetSku() {
	m.sku = nil
	delete(m.clearedFields, lineitem.FieldSku)
}

// SetProductCode sets the "product_code" field.
func (m *LineItemMutation) SetProductCode(s string) {
	m.product_code = &s
}

// ProductCode returns the value of the "product_code" field in the mutation.
func (m *LineItemMutation) ProductCode() (r string, exists bool) {
	v := m.product_code
	if v == nil {
		return
	}
	return *v, true
}

// OldProductCode returns the old "product_code" field's value of the LineItem entity.
// If the LineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LineItemMutation) OldProductCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductCode: %w", err)
	}
	return oldValue.ProductCode, nil
}

// ClearProductCode clears the value of the "product_code" field.
func (m *LineItemMutation) ClearProductCode() {
	m.product_code = nil
	m.clearedFields[lineitem.FieldProductCode] = struct{}{}
}

// ProductCodeCleared returns if the "product_code" field was cleared in this mutation.
func (m *LineItemMutation) ProductCodeCleared() bool {
	_, ok := m.clearedFields[lineitem.FieldProductCode]
	return ok
}

// ResetProductCode resets all changes to the "product_code" field.
func (m *LineItemMutation) ResetProductCode() {
	m.product_code = nil
	delete(m.clearedFields, lineitem.FieldProductCode)
}

// SetQuantity sets the "quantity" field.
func (m *LineItemMutation) SetQuantity(f float64) {
	m.quantity = &f
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *LineItemMutation) Quantity() (r float64, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the LineItem entity.
// If the LineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LineItemMutation) OldQuantity(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds f to the "quantity" field.
func (m *LineItemMutation) AddQuantity(f float64) {
	if m.addquantity != nil {
		*m.addquantity += f
	} else {
		m.addquantity = &f
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *LineItemMutation) AddedQuantity() (r float64, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *LineItemMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetUnit sets the "unit" field.
func (m *LineItemMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the value of the "unit" field in the mutation.
func (m *LineItemMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the LineItem entity.
// If the LineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LineItemMutation) OldUnit(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ClearUnit clears the value of the "unit" field.
func (m *LineItemMutation) ClearUnit() {
	m.unit = nil
	m.clearedFields[lineitem.FieldUnit] = struct{}{}
}

// UnitCleared returns if the "unit" field was cleared in this mutation.
func (m *LineItemMutation) UnitCleared() bool {
	_, ok := m.clearedFields[lineitem.FieldUnit]
	return ok
}

// ResetUnit resets all changes to the "unit" field.
func (m *LineItemMutation) ResetUnit() {
	m.unit = nil
	delete(m.clearedFields, lineitem.FieldUnit)
}

// SetUnitPrice sets the "unit_price" field.
func (m *LineItemMutation) SetUnitPrice(f float64) {
	m.unit_price = &f
	m.addunit_price = nil
}

// UnitPrice returns the value of the "unit_price" field in the mutation.
func (m *LineItemMutation) UnitPrice() (r float64, exists bool) {
	v := m.unit_price
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitPrice returns the old "unit_price" field's value of the LineItem entity.
// If the LineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LineItemMutation) OldUnitPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitPrice: %w", err)
	}
	return oldValue.UnitPrice, nil
}

// AddUnitPrice adds f to the "unit_price" field.
func (m *LineItemMutation) AddUnitPrice(f float64) {
	if m.addunit_price != nil {
		*m.addunit_price += f
	} else {
		m.addunit_price = &f
	}
}

// AddedUnitPrice returns the value that was added to the "unit_price" field in this mutation.
func (m *LineItemMutation) AddedUnitPrice() (r float64, exists bool) {
	v := m.addunit_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnitPrice resets all changes to the "unit_price" field.
func (m *LineItemMutation) ResetUnitPrice() {
	m.unit_price = nil
	m.addunit_price = nil
}

// SetTotalPrice sets the "total_price" field.
func (m *LineItemMutation) SetTotalPrice(f float64) {
	m.total_price = &f
	m.addtotal_price = nil
}

// TotalPrice returns the value of the "total_price" field in the mutation.
func (m *LineItemMutation) TotalPrice() (r float64, exists bool) {
	v := m.total_price
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalPrice returns the old "total_price" field's value of the LineItem entity.
// If the LineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LineItemMutation) OldTotalPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalPrice: %w", err)
	}
	return oldValue.TotalPrice, nil
}

// AddTotalPrice adds f to the "total_price" field.
func (m *LineItemMutation) AddTotalPrice(f float64) {
	if m.addtotal_price != nil {
		*m.addtotal_price += f
	} else {
		m.addtotal_price = &f
	}
}

// AddedTotalPrice returns the value that was added to the "total_price" field in this mutation.
func (m *LineItemMutation) AddedTotalPrice() (r float64, exists bool) {
	v := m.addtotal_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalPrice resets all changes to the "total_price" field.
func (m *LineItemMutation) ResetTotalPrice() {
	m.total_price = nil
	m.addtotal_price = nil
}

// SetDiscountAmount sets the "discount_amount" field.
func (m *LineItemMutation) SetDiscountAmount(f float64) {
	m.discount_amount = &f
	m.adddiscount_amount = nil
}

// DiscountAmount returns the value of the "discount_amount" field in the mutation.
func (m *LineItemMutation) DiscountAmount() (r float64, exists bool) {
	v := m.discount_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscountAmount returns the old "discount_amount" field's value of the LineItem entity.
// If the LineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LineItemMutation) OldDiscountAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscountAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscountAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscountAmount: %w", err)
	}
	return oldValue.DiscountAmount, nil
}

// AddDiscountAmount adds f to the "discount_amount" field.
func (m *LineItemMutation) AddDiscountAmount(f float64) {
	if m.adddiscount_amount != nil {
		*m.adddiscount_amount += f
	} else {
		m.adddiscount_amount = &f
	}
}

// AddedDiscountAmount returns the value that was added to the "discount_amount" field in this mutation.
func (m *LineItemMutation) AddedDiscountAmount() (r float64, exists bool) {
	v := m.adddiscount_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearDiscountAmount clears the value of the "discount_amount" field.
func (m *LineItemMutation) ClearDiscountAmount() {
	m.discount_amount = nil
	m.adddiscount_amount = nil
	m.clearedFields[lineitem.FieldDiscountAmount] = struct{}{}
}

// DiscountAmountCleared returns if the "discount_amount" field was cleared in this mutation.
func (m *LineItemMutation) DiscountAmountCleared() bool {
	_, ok := m.clearedFields[lineitem.FieldDiscountAmount]
	return ok
}

// ResetDiscountAmount resets all changes to the "discount_amount" field.
func (m *LineItemMutation) ResetDiscountAmount() {
	m.discount_amount = nil
	m.adddiscount_amount = nil
	delete(m.clearedFields, lineitem.FieldDiscountAmount)
}

// SetDiscountDescription sets the "discount_description" field.
func (m *LineItemMutation) SetDiscountDescription(s string) {
	m.discount_description = &s
}

// DiscountDescription returns the value of the "discount_description" field in the mutation.
func (m *LineItemMutation) DiscountDescription() (r string, exists bool) {
	v := m.discount_description
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscountDescription returns the old "discount_description" field's value of the LineItem entity.
// If the LineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LineItemMutation) OldDiscountDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscountDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscountDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscountDescription: %w", err)
	}
	return oldValue.DiscountDescription, nil
}

// ClearDiscountDescription clears the value of the "discount_description" field.
func (m *LineItemMutation) ClearDiscountDescription() {
	m.discount_description = nil
	m.clearedFields[lineitem.FieldDiscountDescription] = struct{}{}
}

// DiscountDescriptionCleared returns if the "discount_description" field was cleared in this mutation.
func (m *LineItemMutation) DiscountDescriptionCleared() bool {
	_, ok := m.clearedFields[lineitem.FieldDiscountDescription]
	return ok
}

// ResetDiscountDescription resets all changes to the "discount_description" field.
func (m *LineItemMutation) ResetDiscountDescription() {
	m.discount_description = nil
	delete(m.clearedFields, lineitem.FieldDiscountDescription)
}

// SetTaxAmount sets the "tax_amount" field.
func (m *LineItemMutation) SetTaxAmount(f float64) {
	m.tax_amount = &f
	m.addtax_amount = nil
}

// TaxAmount returns the value of the "tax_amount" field in the mutation.
func (m *LineItemMutation) TaxAmount() (r float64, exists bool) {
	v := m.tax_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxAmount returns the old "tax_amount" field's value of the LineItem entity.
// If the LineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LineItemMutation) OldTaxAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxAmount: %w", err)
	}
	return oldValue.TaxAmount, nil
}

// AddTaxAmount adds f to the "tax_amount" field.
func (m *LineItemMutation) AddTaxAmount(f float64) {
	if m.addtax_amount != nil {
		*m.addtax_amount += f
	} else {
		m.addtax_amount = &f
	}
}

// AddedTaxAmount returns the value that was added to the "tax_amount" field in this mutation.
func (m *LineItemMutation) AddedTaxAmount() (r float64, exists bool) {
	v := m.addtax_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearTaxAmount clears the value of the "tax_amount" field.
func (m *LineItemMutation) ClearTaxAmount() {
	m.tax_amount = nil
	m.addtax_amount = nil
	m.clearedFields[lineitem.FieldTaxAmount] = struct{}{}
}

// TaxAmountCleared returns if the "tax_amount" field was cleared in this mutation.
func (m *LineItemMutation) TaxAmountCleared() bool {
	_, ok := m.clearedFields[lineitem.FieldTaxAmount]
	return ok
}

// ResetTaxAmount resets all changes to the "tax_amount" field.
func (m *LineItemMutation) ResetTaxAmount() {
	m.tax_amount = nil
	m.addtax_amount = nil
	delete(m.clearedFields, lineitem.FieldTaxAmount)
}

// SetTaxRate sets the "tax_rate" field.
func (m *LineItemMutation) SetTaxRate(f float64) {
	m.tax_rate = &f
	m.addtax_rate = nil
}

// TaxRate returns the value of the "tax_rate" field in the mutation.
func (m *LineItemMutation) TaxRate() (r float64, exists bool) {
	v := m.tax_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxRate returns the old "tax_rate" field's value of the LineItem entity.
// If the LineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LineItemMutation) OldTaxRate(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxRate: %w", err)
	}
	return oldValue.TaxRate, nil
}

// AddTaxRate adds f to the "tax_rate" field.
func (m *LineItemMutation) AddTaxRate(f float64) {
	if m.addtax_rate != nil {
		*m.addtax_rate += f
	} else {
		m.addtax_rate = &f
	}
}

// AddedTaxRate returns the value that was added to the "tax_rate" field in this mutation.
func (m *LineItemMutation) AddedTaxRate() (r float64, exists bool) {
	v := m.addtax_rate
	if v == nil {
		return
	}
	return *v, true
}

// ClearTaxRate clears the value of the "tax_rate" field.
func (m *LineItemMutation) ClearTaxRate() {
	m.tax_rate = nil
	m.addtax_rate = nil
	m.clearedFields[lineitem.FieldTaxRate] = struct{}{}
}

// TaxRateCleared returns if the "tax_rate" field was cleared in this mutation.
func (m *LineItemMutation) TaxRateCleared() bool {
	_, ok := m.clearedFields[lineitem.FieldTaxRate]
	return ok
}

// ResetTaxRate resets all changes to the "tax_rate" field.
func (m *LineItemMutation) ResetTaxRate() {
	m.tax_rate = nil
	m.addtax_rate = nil
	delete(m.clearedFields, lineitem.FieldTaxRate)
}

// SetIsTaxable sets the "is_taxable" field.
func (m *LineItemMutation) SetIsTaxable(b bool) {
	m.is_taxable = &b
}

// IsTaxable returns the value of the "is_taxable" field in the mutation.
func (m *LineItemMutation) IsTaxable() (r bool, exists bool) {
	v := m.is_taxable
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTaxable returns the old "is_taxable" field's value of the LineItem entity.
// If the LineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LineItemMutation) OldIsTaxable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTaxable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTaxable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTaxable: %w", err)
	}
	return oldValue.IsTaxable, nil
}

// ResetIsTaxable resets all changes to the "is_taxable" field.
func (m *LineItemMutation) ResetIsTaxable() {
	m.is_taxable = nil
}

// SetCategory sets the "category" field.
func (m *LineItemMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *LineItemMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the LineItem entity.
// If the LineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LineItemMutation) OldCategory(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *LineItemMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[lineitem.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *LineItemMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[lineitem.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *LineItemMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, lineitem.FieldCategory)
}

// SetTags sets the "tags" field.
func (m *LineItemMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *LineItemMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the LineItem entity.
// If the LineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LineItemMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *LineItemMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *LineItemMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *LineItemMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[lineitem.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *LineItemMutation) TagsCleared() bool {
	_, ok := m.clearedFields[lineitem.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *LineItemMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, lineitem.FieldTags)
}

// SetMetadata sets the "metadata" field.
func (m *LineItemMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *LineItemMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the LineItem entity.
// If the LineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LineItemMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *LineItemMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[lineitem.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *LineItemMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[lineitem.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *LineItemMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, lineitem.FieldMetadata)
}

// SetLegacyID sets the "legacy_id" field.
func (m *LineItemMutation) SetLegacyID(s string) {
	m.legacy_id = &s
}

// LegacyID returns the value of the "legacy_id" field in the mutation.
func (m *LineItemMutation) LegacyID() (r string, exists bool) {
	v := m.legacy_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLegacyID returns the old "legacy_id" field's value of the LineItem entity.
// If the LineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LineItemMutation) OldLegacyID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLegacyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLegacyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLegacyID: %w", err)
	}
	return oldValue.LegacyID, nil
}

// ClearLegacyID clears the value of the "legacy_id" field.
func (m *LineItemMutation) ClearLegacyID() {
	m.legacy_id = nil
	m.clearedFields[lineitem.FieldLegacyID] = struct{}{}
}

// LegacyIDCleared returns if the "legacy_id" field was cleared in this mutation.
func (m *LineItemMutation) LegacyIDCleared() bool {
	_, ok := m.clearedFields[lineitem.FieldLegacyID]
	return ok
}

// ResetLegacyID resets all changes to the "legacy_id" field.
func (m *LineItemMutation) ResetLegacyID() {
	m.legacy_id = nil
	delete(m.clearedFields, lineitem.FieldLegacyID)
}

// SetCreatedAt sets the "created_at" field.
func (m *LineItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LineItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LineItem entity.
// If the LineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LineItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LineItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LineItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LineItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LineItem entity.
// If the LineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LineItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LineItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearReceipt clears the "receipt" edge to the Receipt entity.
func (m *LineItemMutation) ClearReceipt() {
	m.clearedreceipt = true
	m.clearedFields[lineitem.FieldReceiptID] = struct{}{}
}

// ReceiptCleared reports if the "receipt" edge to the Receipt entity was cleared.
func (m *LineItemMutation) ReceiptCleared() bool {
	return m.clearedreceipt
}

// ReceiptIDs returns the "receipt" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReceiptID instead. It exists only for internal usage by the builders.
func (m *LineItemMutation) ReceiptIDs() (ids []string) {
	if id := m.receipt; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReceipt resets all changes to the "receipt" edge.
func (m *LineItemMutation) ResetReceipt() {
	m.receipt = nil
	m.clearedreceipt = false
}

// Where appends a list predicates to the LineItemMutation builder.
func (m *LineItemMutation) Where(ps ...predicate.LineItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LineItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LineItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LineItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LineItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LineItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LineItem).
func (m *LineItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LineItemMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.receipt != nil {
		fields = append(fields, lineitem.FieldReceiptID)
	}
	if m.line_number != nil {
		fields = append(fields, lineitem.FieldLineNumber)
	}
	if m.description != nil {
		fields = append(fields, lineitem.FieldDescription)
	}
	if m.sku != nil {
		fields = append(fields, lineitem.FieldSku)
	}
	if m.product_code != nil {
		fields = append(fields, lineitem.FieldProductCode)
	}
	if m.quantity != nil {
		fields = append(fields, lineitem.FieldQuantity)
	}
	if m.unit != nil {
		fields = append(fields, lineitem.FieldUnit)
	}
	if m.unit_price != nil {
		fields = append(fields, lineitem.FieldUnitPrice)
	}
	if m.total_price != nil {
		fields = append(fields, lineitem.FieldTotalPrice)
	}
	if m.discount_amount != nil {
		fields = append(fields, lineitem.FieldDiscountAmount)
	}
	if m.discount_description != nil {
		fields = append(fields, lineitem.FieldDiscountDescription)
	}
	if m.tax_amount != nil {
		fields = append(fields, lineitem.FieldTaxAmount)
	}
	if m.tax_rate != nil {
		fields = append(fields, lineitem.FieldTaxRate)
	}
	if m.is_taxable != nil {
		fields = append(fields, lineitem.FieldIsTaxable)
	}
	if m.category != nil {
		fields = append(fields, lineitem.FieldCategory)
	}
	if m.tags != nil {
		fields = append(fields, lineitem.FieldTags)
	}
	if m.metadata != nil {
		fields = append(fields, lineitem.FieldMetadata)
	}
	if m.legacy_id != nil {
		fields = append(fields, lineitem.FieldLegacyID)
	}
	if m.created_at != nil {
		fields = append(fields, lineitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, lineitem.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LineItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lineitem.FieldReceiptID:
		return m.ReceiptID()
	case lineitem.FieldLineNumber:
		return m.LineNumber()
	case lineitem.FieldDescription:
		return m.Description()
	case lineitem.FieldSku:
		return m.Sku()
	case lineitem.FieldProductCode:
		return m.ProductCode()
	case lineitem.FieldQuantity:
		return m.Quantity()
	case lineitem.FieldUnit:
		return m.Unit()
	case lineitem.FieldUnitPrice:
		return m.UnitPrice()
	case lineitem.FieldTotalPrice:
		return m.TotalPrice()
	case lineitem.FieldDiscountAmount:
		return m.DiscountAmount()
	case lineitem.FieldDiscountDescription:
		return m.DiscountDescription()
	case lineitem.FieldTaxAmount:
		return m.TaxAmount()
	case lineitem.FieldTaxRate:
		return m.TaxRate()
	case lineitem.FieldIsTaxable:
		return m.IsTaxable()
	case lineitem.FieldCategory:
		return m.Category()
	case lineitem.FieldTags:
		return m.Tags()
	case lineitem.FieldMetadata:
		return m.Metadata()
	case lineitem.FieldLegacyID:
		return m.LegacyID()
	case lineitem.FieldCreatedAt:
		return m.CreatedAt()
	case lineitem.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LineItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lineitem.FieldReceiptID:
		return m.OldReceiptID(ctx)
	case lineitem.FieldLineNumber:
		return m.OldLineNumber(ctx)
	case lineitem.FieldDescription:
		return m.OldDescription(ctx)
	case lineitem.FieldSku:
		return m.OldSku(ctx)
	case lineitem.FieldProductCode:
		return m.OldProductCode(ctx)
	case lineitem.FieldQuantity:
		return m.OldQuantity(ctx)
	case lineitem.FieldUnit:
		return m.OldUnit(ctx)
	case lineitem.FieldUnitPrice:
		return m.OldUnitPrice(ctx)
	case lineitem.FieldTotalPrice:
		return m.OldTotalPrice(ctx)
	case lineitem.FieldDiscountAmount:
		return m.OldDiscountAmount(ctx)
	case lineitem.FieldDiscountDescription:
		return m.OldDiscountDescription(ctx)
	case lineitem.FieldTaxAmount:
		return m.OldTaxAmount(ctx)
	case lineitem.FieldTaxRate:
		return m.OldTaxRate(ctx)
	case lineitem.FieldIsTaxable:
		return m.OldIsTaxable(ctx)
	case lineitem.FieldCategory:
		return m.OldCategory(ctx)
	case lineitem.FieldTags:
		return m.OldTags(ctx)
	case lineitem.FieldMetadata:
		return m.OldMetadata(ctx)
	case lineitem.FieldLegacyID:
		return m.OldLegacyID(ctx)
	case lineitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case lineitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown LineItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LineItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lineitem.FieldReceiptID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiptID(v)
		return nil
	case lineitem.FieldLineNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLineNumber(v)
		return nil
	case lineitem.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case lineitem.FieldSku:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSku(v)
		return nil
	case lineitem.FieldProductCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductCode(v)
		return nil
	case lineitem.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case lineitem.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case lineitem.FieldUnitPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitPrice(v)
		return nil
	case lineitem.FieldTotalPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalPrice(v)
		return nil
	case lineitem.FieldDiscountAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscountAmount(v)
		return nil
	case lineitem.FieldDiscountDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscountDescription(v)
		return nil
	case lineitem.FieldTaxAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxAmount(v)
		return nil
	case lineitem.FieldTaxRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxRate(v)
		return nil
	case lineitem.FieldIsTaxable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTaxable(v)
		return nil
	case lineitem.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case lineitem.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case lineitem.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case lineitem.FieldLegacyID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLegacyID(v)
		return nil
	case lineitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case lineitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown LineItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LineItemMutation) AddedFields() []string {
	var fields []string
	if m.addline_number != nil {
		fields = append(fields, lineitem.FieldLineNumber)
	}
	if m.addquantity != nil {
		fields = append(fields, lineitem.FieldQuantity)
	}
	if m.addunit_price != nil {
		fields = append(fields, lineitem.FieldUnitPrice)
	}
	if m.addtotal_price != nil {
		fields = append(fields, lineitem.FieldTotalPrice)
	}
	if m.adddiscount_amount != nil {
		fields = append(fields, lineitem.FieldDiscountAmount)
	}
	if m.addtax_amount != nil {
		fields = append(fields, lineitem.FieldTaxAmount)
	}
	if m.addtax_rate != nil {
		fields = append(fields, lineitem.FieldTaxRate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LineItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case lineitem.FieldLineNumber:
		return m.AddedLineNumber()
	case lineitem.FieldQuantity:
		return m.AddedQuantity()
	case lineitem.FieldUnitPrice:
		return m.AddedUnitPrice()
	case lineitem.FieldTotalPrice:
		return m.AddedTotalPrice()
	case lineitem.FieldDiscountAmount:
		return m.AddedDiscountAmount()
	case lineitem.FieldTaxAmount:
		return m.AddedTaxAmount()
	case lineitem.FieldTaxRate:
		return m.AddedTaxRate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LineItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case lineitem.FieldLineNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLineNumber(v)
		return nil
	case lineitem.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case lineitem.FieldUnitPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitPrice(v)
		return nil
	case lineitem.FieldTotalPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalPrice(v)
		return nil
	case lineitem.FieldDiscountAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiscountAmount(v)
		return nil
	case lineitem.FieldTaxAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaxAmount(v)
		return nil
	case lineitem.FieldTaxRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaxRate(v)
		return nil
	}
	return fmt.Errorf("unknown LineItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LineItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(lineitem.FieldSku) {
		fields = append(fields, lineitem.FieldSku)
	}
	if m.FieldCleared(lineitem.FieldProductCode) {
		fields = append(fields, lineitem.FieldProductCode)
	}
	if m.FieldCleared(lineitem.FieldUnit) {
		fields = append(fields, lineitem.FieldUnit)
	}
	if m.FieldCleared(lineitem.FieldDiscountAmount) {
		fields = append(fields, lineitem.FieldDiscountAmount)
	}
	if m.FieldCleared(lineitem.FieldDiscountDescription) {
		fields = append(fields, lineitem.FieldDiscountDescription)
	}
	if m.FieldCleared(lineitem.FieldTaxAmount) {
		fields = append(fields, lineitem.FieldTaxAmount)
	}
	if m.FieldCleared(lineitem.FieldTaxRate) {
		fields = append(fields, lineitem.FieldTaxRate)
	}
	if m.FieldCleared(lineitem.FieldCategory) {
		fields = append(fields, lineitem.FieldCategory)
	}
	if m.FieldCleared(lineitem.FieldTags) {
		fields = append(fields, lineitem.FieldTags)
	}
	if m.FieldCleared(lineitem.FieldMetadata) {
		fields = append(fields, lineitem.FieldMetadata)
	}
	if m.FieldCleared(lineitem.FieldLegacyID) {
		fields = append(fields, lineitem.FieldLegacyID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LineItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LineItemMutation) ClearField(name string) error {
	switch name {
	case lineitem.FieldSku:
		m.ClearSku()
		return nil
	case lineitem.FieldProductCode:
		m.ClearProductCode()
		return nil
	case lineitem.FieldUnit:
		m.ClearUnit()
		return nil
	case lineitem.FieldDiscountAmount:
		m.ClearDiscountAmount()
		return nil
	case lineitem.FieldDiscountDescription:
		m.ClearDiscountDescription()
		return nil
	case lineitem.FieldTaxAmount:
		m.ClearTaxAmount()
		return nil
	case lineitem.FieldTaxRate:
		m.ClearTaxRate()
		return nil
	case lineitem.FieldCategory:
		m.ClearCategory()
		return nil
	case lineitem.FieldTags:
		m.ClearTags()
		return nil
	case lineitem.FieldMetadata:
		m.ClearMetadata()
		return nil
	case lineitem.FieldLegacyID:
		m.ClearLegacyID()
		return nil
	}
	return fmt.Errorf("unknown LineItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LineItemMutation) ResetField(name string) error {
	switch name {
	case lineitem.FieldReceiptID:
		m.ResetReceiptID()
		return nil
	case lineitem.FieldLineNumber:
		m.ResetLineNumber()
		return nil
	case lineitem.FieldDescription:
		m.ResetDescription()
		return nil
	case lineitem.FieldSku:
		m.ResetSku()
		return nil
	case lineitem.FieldProductCode:
		m.ResetProductCode()
		return nil
	case lineitem.FieldQuantity:
		m.ResetQuantity()
		return nil
	case lineitem.FieldUnit:
		m.ResetUnit()
		return nil
	case lineitem.FieldUnitPrice:
		m.ResetUnitPrice()
		return nil
	case lineitem.FieldTotalPrice:
		m.ResetTotalPrice()
		return nil
	case lineitem.FieldDiscountAmount:
		m.ResetDiscountAmount()
		return nil
	case lineitem.FieldDiscountDescription:
		m.ResetDiscountDescription()
		return nil
	case lineitem.FieldTaxAmount:
		m.ResetTaxAmount()
		return nil
	case lineitem.FieldTaxRate:
		m.ResetTaxRate()
		return nil
	case lineitem.FieldIsTaxable:
		m.ResetIsTaxable()
		return nil
	case lineitem.FieldCategory:
		m.ResetCategory()
		return nil
	case lineitem.FieldTags:
		m.ResetTags()
		return nil
	case lineitem.FieldMetadata:
		m.ResetMetadata()
		return nil
	case lineitem.FieldLegacyID:
		m.ResetLegacyID()
		return nil
	case lineitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case lineitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown LineItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LineItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.receipt != nil {
		edges = append(edges, lineitem.EdgeReceipt)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LineItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lineitem.EdgeReceipt:
		if id := m.receipt; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LineItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LineItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LineItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedreceipt {
		edges = append(edges, lineitem.EdgeReceipt)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LineItemMutation) EdgeCleared(name string) bool {
	switch name {
	case lineitem.EdgeReceipt:
		return m.clearedreceipt
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LineItemMutation) ClearEdge(name string) error {
	switch name {
	case lineitem.EdgeReceipt:
		m.ClearReceipt()
		return nil
	}
	return fmt.Errorf("unknown LineItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LineItemMutation) ResetEdge(name string) error {
	switch name {
	case lineitem.EdgeReceipt:
		m.ResetReceipt()
		return nil
	}
	return fmt.Errorf("unknown LineItem edge %s", name)
}

// ReceiptMutation represents an operation that mutates the Receipt nodes in the graph.
type ReceiptMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	user_id              *string
	source_type          *receipt.SourceType
	source_id            *string
	source_connection_id *string
	file_name            *string
	file_path            *string
	mime_type            *string
	file_size            *int64
	addfile_size         *int64
	storage_bucket       *string
	storage_key          *string
	thumbnail_path       *string
	status               *receipt.Status
	ocr_completed        *bool
	ocr_text             *string
	ocr_confidence       *float64
	addocr_confidence    *float64
	merchant_name        *string
	merchant_address     *string
	receipt_date         *time.Time
	total_amount         *float64
	addtotal_amount      *float64
	tax_amount           *float64
	addtax_amount        *float64
	subtotal_amount      *float64
	addsubtotal_amount   *float64
	currency             *string
	payment_method       *string
	receipt_number       *string
	category_tags        *[]string
	appendcategory_tags  []string
	extracted_data       *map[string]interface{}
	metadata             *map[string]interface{}
	notes                *string
	legacy_id            *string
	created_at           *time.Time
	updated_at           *time.Time
	processed_at         *time.Time
	clearedFields        map[string]struct{}
	transactions         map[string]struct{}
	removedtransactions  map[string]struct{}
	clearedtransactions  bool
	line_items           map[string]struct{}
	removedline_items    map[string]struct{}
	clearedline_items    bool
	done                 bool
	oldValue             func(context.Context) (*Receipt, error)
	predicates           []predicate.Receipt
}

var _ ent.Mutation = (*ReceiptMutation)(nil)

// receiptOption allows management of the mutation configuration using functional options.
type receiptOption func(*ReceiptMutation)

// newReceiptMutation creates new mutation for the Receipt entity.
func newReceiptMutation(c config, op Op, opts ...receiptOption) *ReceiptMutation {
	m := &ReceiptMutation{
		config:        c,
		op:            op,
		typ:           TypeReceipt,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReceiptID sets the ID field of the mutation.
func withReceiptID(id string) receiptOption {
	return func(m *ReceiptMutation) {
		var (
			err   error
			once  sync.Once
			value *Receipt
		)
		m.oldValue = func(ctx context.Context) (*Receipt, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Receipt.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReceipt sets the old Receipt of the mutation.
func withReceipt(node *Receipt) receiptOption {
	return func(m *ReceiptMutation) {
		m.oldValue = func(context.Context) (*Receipt, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReceiptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReceiptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Receipt entities.
func (m *ReceiptMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReceiptMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReceiptMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Receipt.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *ReceiptMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ReceiptMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ReceiptMutation) ResetUserID() {
	m.user_id = nil
}

// SetSourceType sets the "source_type" field.
func (m *ReceiptMutation) SetSourceType(rt receipt.SourceType) {
	m.source_type = &rt
}

// SourceType returns the value of the "source_type" field in the mutation.
func (m *ReceiptMutation) SourceType() (r receipt.SourceType, exists bool) {
	v := m.source_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceType returns the old "source_type" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldSourceType(ctx context.Context) (v receipt.SourceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceType: %w", err)
	}
	return oldValue.SourceType, nil
}

// ResetSourceType resets all changes to the "source_type" field.
func (m *ReceiptMutation) ResetSourceType() {
	m.source_type = nil
}

// SetSourceID sets the "source_id" field.
func (m *ReceiptMutation) SetSourceID(s string) {
	m.source_id = &s
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *ReceiptMutation) SourceID() (r string, exists bool) {
	v := m.source_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldSourceID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ClearSourceID clears the value of the "source_id" field.
func (m *ReceiptMutation) ClearSourceID() {
	m.source_id = nil
	m.clearedFields[receipt.FieldSourceID] = struct{}{}
}

// SourceIDCleared returns if the "source_id" field was cleared in this mutation.
func (m *ReceiptMutation) SourceIDCleared() bool {
	_, ok := m.clearedFields[receipt.FieldSourceID]
	return ok
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *ReceiptMutation) ResetSourceID() {
	m.source_id = nil
	delete(m.clearedFields, receipt.FieldSourceID)
}

// SetSourceConnectionID sets the "source_connection_id" field.
func (m *ReceiptMutation) SetSourceConnectionID(s string) {
	m.source_connection_id = &s
}

// SourceConnectionID returns the value of the "source_connection_id" field in the mutation.
func (m *ReceiptMutation) SourceConnectionID() (r string, exists bool) {
	v := m.source_connection_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceConnectionID returns the old "source_connection_id" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldSourceConnectionID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceConnectionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceConnectionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceConnectionID: %w", err)
	}
	return oldValue.SourceConnectionID, nil
}

// ClearSourceConnectionID clears the value of the "source_connection_id" field.
func (m *ReceiptMutation) ClearSourceConnectionID() {
	m.source_connection_id = nil
	m.clearedFields[receipt.FieldSourceConnectionID] = struct{}{}
}

// SourceConnectionIDCleared returns if the "source_connection_id" field was cleared in this mutation.
func (m *ReceiptMutation) SourceConnectionIDCleared() bool {
	_, ok := m.clearedFields[receipt.FieldSourceConnectionID]
	return ok
}

// ResetSourceConnectionID resets all changes to the "source_connection_id" field.
func (m *ReceiptMutation) ResetSourceConnectionID() {
	m.source_connection_id = nil
	delete(m.clearedFields, receipt.FieldSourceConnectionID)
}

// SetFileName sets the "file_name" field.
func (m *ReceiptMutation) SetFileName(s string) {
	m.file_name = &s
}

// FileName returns the value of the "file_name" field in the mutation.
func (m *ReceiptMutation) FileName() (r string, exists bool) {
	v := m.file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFileName returns the old "file_name" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldFileName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileName: %w", err)
	}
	return oldValue.FileName, nil
}

// ResetFileName resets all changes to the "file_name" field.
func (m *ReceiptMutation) ResetFileName() {
	m.file_name = nil
}

// SetFilePath sets the "file_path" field.
func (m *ReceiptMutation) SetFilePath(s string) {
	m.file_path = &s
}

// FilePath returns the value of the "file_path" field in the mutation.
func (m *ReceiptMutation) FilePath() (r string, exists bool) {
	v := m.file_path
	if v == nil {
		return
	}
	return *v, true
}

// OldFilePath returns the old "file_path" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldFilePath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilePath: %w", err)
	}
	return oldValue.FilePath, nil
}

// ClearFilePath clears the value of the "file_path" field.
func (m *ReceiptMutation) ClearFilePath() {
	m.file_path = nil
	m.clearedFields[receipt.FieldFilePath] = struct{}{}
}

// FilePathCleared returns if the "file_path" field was cleared in this mutation.
func (m *ReceiptMutation) FilePathCleared() bool {
	_, ok := m.clearedFields[receipt.FieldFilePath]
	return ok
}

// ResetFilePath resets all changes to the "file_path" field.
func (m *ReceiptMutation) ResetFilePath() {
	m.file_path = nil
	delete(m.clearedFields, receipt.FieldFilePath)
}

// SetMimeType sets the "mime_type" field.
func (m *ReceiptMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *ReceiptMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *ReceiptMutation) ResetMimeType() {
	m.mime_type = nil
}

// SetFileSize sets the "file_size" field.
func (m *ReceiptMutation) SetFileSize(i int64) {
	m.file_size = &i
	m.addfile_size = nil
}

// FileSize returns the value of the "file_size" field in the mutation.
func (m *ReceiptMutation) FileSize() (r int64, exists bool) {
	v := m.file_size
	if v == nil {
		return
	}
	return *v, true
}

// OldFileSize returns the old "file_size" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldFileSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileSize: %w", err)
	}
	return oldValue.FileSize, nil
}

// AddFileSize adds i to the "file_size" field.
func (m *ReceiptMutation) AddFileSize(i int64) {
	if m.addfile_size != nil {
		*m.addfile_size += i
	} else {
		m.addfile_size = &i
	}
}

// AddedFileSize returns the value that was added to the "file_size" field in this mutation.
func (m *ReceiptMutation) AddedFileSize() (r int64, exists bool) {
	v := m.addfile_size
	if v == nil {
		return
	}
	return *v, true
}

// ResetFileSize resets all changes to the "file_size" field.
func (m *ReceiptMutation) ResetFileSize() {
	m.file_size = nil
	m.addfile_size = nil
}

// SetStorageBucket sets the "storage_bucket" field.
func (m *ReceiptMutation) SetStorageBucket(s string) {
	m.storage_bucket = &s
}

// StorageBucket returns the value of the "storage_bucket" field in the mutation.
func (m *ReceiptMutation) StorageBucket() (r string, exists bool) {
	v := m.storage_bucket
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageBucket returns the old "storage_bucket" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldStorageBucket(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageBucket is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageBucket requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageBucket: %w", err)
	}
	return oldValue.StorageBucket, nil
}

// ClearStorageBucket clears the value of the "storage_bucket" field.
func (m *ReceiptMutation) ClearStorageBucket() {
	m.storage_bucket = nil
	m.clearedFields[receipt.FieldStorageBucket] = struct{}{}
}

// StorageBucketCleared returns if the "storage_bucket" field was cleared in this mutation.
func (m *ReceiptMutation) StorageBucketCleared() bool {
	_, ok := m.clearedFields[receipt.FieldStorageBucket]
	return ok
}

// ResetStorageBucket resets all changes to the "storage_bucket" field.
func (m *ReceiptMutation) ResetStorageBucket() {
	m.storage_bucket = nil
	delete(m.clearedFields, receipt.FieldStorageBucket)
}

// SetStorageKey sets the "storage_key" field.
func (m *ReceiptMutation) SetStorageKey(s string) {
	m.storage_key = &s
}

// StorageKey returns the value of the "storage_key" field in the mutation.
func (m *ReceiptMutation) StorageKey() (r string, exists bool) {
	v := m.storage_key
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageKey returns the old "storage_key" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldStorageKey(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageKey: %w", err)
	}
	return oldValue.StorageKey, nil
}

// ClearStorageKey clears the value of the "storage_key" field.
func (m *ReceiptMutation) ClearStorageKey() {
	m.storage_key = nil
	m.clearedFields[receipt.FieldStorageKey] = struct{}{}
}

// StorageKeyCleared returns if the "storage_key" field was cleared in this mutation.
func (m *ReceiptMutation) StorageKeyCleared() bool {
	_, ok := m.clearedFields[receipt.FieldStorageKey]
	return ok
}

// ResetStorageKey resets all changes to the "storage_key" field.
func (m *ReceiptMutation) ResetStorageKey() {
	m.storage_key = nil
	delete(m.clearedFields, receipt.FieldStorageKey)
}

// SetThumbnailPath sets the "thumbnail_path" field.
func (m *ReceiptMutation) SetThumbnailPath(s string) {
	m.thumbnail_path = &s
}

// ThumbnailPath returns the value of the "thumbnail_path" field in the mutation.
func (m *ReceiptMutation) ThumbnailPath() (r string, exists bool) {
	v := m.thumbnail_path
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailPath returns the old "thumbnail_path" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldThumbnailPath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailPath: %w", err)
	}
	return oldValue.ThumbnailPath, nil
}

// ClearThumbnailPath clears the value of the "thumbnail_path" field.
func (m *ReceiptMutation) ClearThumbnailPath() {
	m.thumbnail_path = nil
	m.clearedFields[receipt.FieldThumbnailPath] = struct{}{}
}

// ThumbnailPathCleared returns if the "thumbnail_path" field was cleared in this mutation.
func (m *ReceiptMutation) ThumbnailPathCleared() bool {
	_, ok := m.clearedFields[receipt.FieldThumbnailPath]
	return ok
}

// ResetThumbnailPath resets all changes to the "thumbnail_path" field.
func (m *ReceiptMutation) ResetThumbnailPath() {
	m.thumbnail_path = nil
	delete(m.clearedFields, receipt.FieldThumbnailPath)
}

// SetStatus sets the "status" field.
func (m *ReceiptMutation) SetStatus(r receipt.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *ReceiptMutation) Status() (r receipt.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldStatus(ctx context.Context) (v receipt.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ReceiptMutation) ResetStatus() {
	m.status = nil
}

// SetOcrCompleted sets the "ocr_completed" field.
func (m *ReceiptMutation) SetOcrCompleted(b bool) {
	m.ocr_completed = &b
}

// OcrCompleted returns the value of the "ocr_completed" field in the mutation.
func (m *ReceiptMutation) OcrCompleted() (r bool, exists bool) {
	v := m.ocr_completed
	if v == nil {
		return
	}
	return *v, true
}

// OldOcrCompleted returns the old "ocr_completed" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldOcrCompleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOcrCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOcrCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOcrCompleted: %w", err)
	}
	return oldValue.OcrCompleted, nil
}

// ResetOcrCompleted resets all changes to the "ocr_completed" field.
func (m *ReceiptMutation) ResetOcrCompleted() {
	m.ocr_completed = nil
}

// SetOcrText sets the "ocr_text" field.
func (m *ReceiptMutation) SetOcrText(s string) {
	m.ocr_text = &s
}

// OcrText returns the value of the "ocr_text" field in the mutation.
func (m *ReceiptMutation) OcrText() (r string, exists bool) {
	v := m.ocr_text
	if v == nil {
		return
	}
	return *v, true
}

// OldOcrText returns the old "ocr_text" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldOcrText(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOcrText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOcrText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOcrText: %w", err)
	}
	return oldValue.OcrText, nil
}

// ClearOcrText clears the value of the "ocr_text" field.
func (m *ReceiptMutation) ClearOcrText() {
	m.ocr_text = nil
	m.clearedFields[receipt.FieldOcrText] = struct{}{}
}

// OcrTextCleared returns if the "ocr_text" field was cleared in this mutation.
func (m *ReceiptMutation) OcrTextCleared() bool {
	_, ok := m.clearedFields[receipt.FieldOcrText]
	return ok
}

// ResetOcrText resets all changes to the "ocr_text" field.
func (m *ReceiptMutation) ResetOcrText() {
	m.ocr_text = nil
	delete(m.clearedFields, receipt.FieldOcrText)
}

// SetOcrConfidence sets the "ocr_confidence" field.
func (m *ReceiptMutation) SetOcrConfidence(f float64) {
	m.ocr_confidence = &f
	m.addocr_confidence = nil
}

// OcrConfidence returns the value of the "ocr_confidence" field in the mutation.
func (m *ReceiptMutation) OcrConfidence() (r float64, exists bool) {
	v := m.ocr_confidence
	if v == nil {
		return
	}
	return *v, true
}

// OldOcrConfidence returns the old "ocr_confidence" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldOcrConfidence(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOcrConfidence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOcrConfidence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOcrConfidence: %w", err)
	}
	return oldValue.OcrConfidence, nil
}

// AddOcrConfidence adds f to the "ocr_confidence" field.
func (m *ReceiptMutation) AddOcrConfidence(f float64) {
	if m.addocr_confidence != nil {
		*m.addocr_confidence += f
	} else {
		m.addocr_confidence = &f
	}
}

// AddedOcrConfidence returns the value that was added to the "ocr_confidence" field in this mutation.
func (m *ReceiptMutation) AddedOcrConfidence() (r float64, exists bool) {
	v := m.addocr_confidence
	if v == nil {
		return
	}
	return *v, true
}

// ClearOcrConfidence clears the value of the "ocr_confidence" field.
func (m *ReceiptMutation) ClearOcrConfidence() {
	m.ocr_confidence = nil
	m.addocr_confidence = nil
	m.clearedFields[receipt.FieldOcrConfidence] = struct{}{}
}

// OcrConfidenceCleared returns if the "ocr_confidence" field was cleared in this mutation.
func (m *ReceiptMutation) OcrConfidenceCleared() bool {
	_, ok := m.clearedFields[receipt.FieldOcrConfidence]
	return ok
}

// ResetOcrConfidence resets all changes to the "ocr_confidence" field.
func (m *ReceiptMutation) ResetOcrConfidence() {
	m.ocr_confidence = nil
	m.addocr_confidence = nil
	delete(m.clearedFields, receipt.FieldOcrConfidence)
}

// SetMerchantName sets the "merchant_name" field.
func (m *ReceiptMutation) SetMerchantName(s string) {
	m.merchant_name = &s
}

// MerchantName returns the value of the "merchant_name" field in the mutation.
func (m *ReceiptMutation) MerchantName() (r string, exists bool) {
	v := m.merchant_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantName returns the old "merchant_name" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldMerchantName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantName: %w", err)
	}
	return oldValue.MerchantName, nil
}

// ClearMerchantName clears the value of the "merchant_name" field.
func (m *ReceiptMutation) ClearMerchantName() {
	m.merchant_name = nil
	m.clearedFields[receipt.FieldMerchantName] = struct{}{}
}

// MerchantNameCleared returns if the "merchant_name" field was cleared in this mutation.
func (m *ReceiptMutation) MerchantNameCleared() bool {
	_, ok := m.clearedFields[receipt.FieldMerchantName]
	return ok
}

// ResetMerchantName resets all changes to the "merchant_name" field.
func (m *ReceiptMutation) ResetMerchantName() {
	m.merchant_name = nil
	delete(m.clearedFields, receipt.FieldMerchantName)
}

// SetMerchantAddress sets the "merchant_address" field.
func (m *ReceiptMutation) SetMerchantAddress(s string) {
	m.merchant_address = &s
}

// MerchantAddress returns the value of the "merchant_address" field in the mutation.
func (m *ReceiptMutation) MerchantAddress() (r string, exists bool) {
	v := m.merchant_address
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantAddress returns the old "merchant_address" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldMerchantAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantAddress: %w", err)
	}
	return oldValue.MerchantAddress, nil
}

// ClearMerchantAddress clears the value of the "merchant_address" field.
func (m *ReceiptMutation) ClearMerchantAddress() {
	m.merchant_address = nil
	m.clearedFields[receipt.FieldMerchantAddress] = struct{}{}
}

// MerchantAddressCleared returns if the "merchant_address" field was cleared in this mutation.
func (m *ReceiptMutation) MerchantAddressCleared() bool {
	_, ok := m.clearedFields[receipt.FieldMerchantAddress]
	return ok
}

// ResetMerchantAddress resets all changes to the "merchant_address" field.
func (m *ReceiptMutation) ResetMerchantAddress() {
	m.merchant_address = nil
	delete(m.clearedFields, receipt.FieldMerchantAddress)
}

// SetReceiptDate sets the "receipt_date" field.
func (m *ReceiptMutation) SetReceiptDate(t time.Time) {
	m.receipt_date = &t
}

// ReceiptDate returns the value of the "receipt_date" field in the mutation.
func (m *ReceiptMutation) ReceiptDate() (r time.Time, exists bool) {
	v := m.receipt_date
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiptDate returns the old "receipt_date" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldReceiptDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiptDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiptDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiptDate: %w", err)
	}
	return oldValue.ReceiptDate, nil
}

// ClearReceiptDate clears the value of the "receipt_date" field.
func (m *ReceiptMutation) ClearReceiptDate() {
	m.receipt_date = nil
	m.clearedFields[receipt.FieldReceiptDate] = struct{}{}
}

// ReceiptDateCleared returns if the "receipt_date" field was cleared in this mutation.
func (m *ReceiptMutation) ReceiptDateCleared() bool {
	_, ok := m.clearedFields[receipt.FieldReceiptDate]
	return ok
}

// ResetReceiptDate resets all changes to the "receipt_date" field.
func (m *ReceiptMutation) ResetReceiptDate() {
	m.receipt_date = nil
	delete(m.clearedFields, receipt.FieldReceiptDate)
}

// SetTotalAmount sets the "total_amount" field.
func (m *ReceiptMutation) SetTotalAmount(f float64) {
	m.total_amount = &f
	m.addtotal_amount = nil
}

// TotalAmount returns the value of the "total_amount" field in the mutation.
func (m *ReceiptMutation) TotalAmount() (r float64, exists bool) {
	v := m.total_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalAmount returns the old "total_amount" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldTotalAmount(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalAmount: %w", err)
	}
	return oldValue.TotalAmount, nil
}

// AddTotalAmount adds f to the "total_amount" field.
func (m *ReceiptMutation) AddTotalAmount(f float64) {
	if m.addtotal_amount != nil {
		*m.addtotal_amount += f
	} else {
		m.addtotal_amount = &f
	}
}

// AddedTotalAmount returns the value that was added to the "total_amount" field in this mutation.
func (m *ReceiptMutation) AddedTotalAmount() (r float64, exists bool) {
	v := m.addtotal_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalAmount clears the value of the "total_amount" field.
func (m *ReceiptMutation) ClearTotalAmount() {
	m.total_amount = nil
	m.addtotal_amount = nil
	m.clearedFields[receipt.FieldTotalAmount] = struct{}{}
}

// TotalAmountCleared returns if the "total_amount" field was cleared in this mutation.
func (m *ReceiptMutation) TotalAmountCleared() bool {
	_, ok := m.clearedFields[receipt.FieldTotalAmount]
	return ok
}

// ResetTotalAmount resets all changes to the "total_amount" field.
func (m *ReceiptMutation) ResetTotalAmount() {
	m.total_amount = nil
	m.addtotal_amount = nil
	delete(m.clearedFields, receipt.FieldTotalAmount)
}

// SetTaxAmount sets the "tax_amount" field.
func (m *ReceiptMutation) SetTaxAmount(f float64) {
	m.tax_amount = &f
	m.addtax_amount = nil
}

// TaxAmount returns the value of the "tax_amount" field in the mutation.
func (m *ReceiptMutation) TaxAmount() (r float64, exists bool) {
	v := m.tax_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxAmount returns the old "tax_amount" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldTaxAmount(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxAmount: %w", err)
	}
	return oldValue.TaxAmount, nil
}

// AddTaxAmount adds f to the "tax_amount" field.
func (m *ReceiptMutation) AddTaxAmount(f float64) {
	if m.addtax_amount != nil {
		*m.addtax_amount += f
	} else {
		m.addtax_amount = &f
	}
}

// AddedTaxAmount returns the value that was added to the "tax_amount" field in this mutation.
func (m *ReceiptMutation) AddedTaxAmount() (r float64, exists bool) {
	v := m.addtax_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearTaxAmount clears the value of the "tax_amount" field.
func (m *ReceiptMutation) ClearTaxAmount() {
	m.tax_amount = nil
	m.addtax_amount = nil
	m.clearedFields[receipt.FieldTaxAmount] = struct{}{}
}

// TaxAmountCleared returns if the "tax_amount" field was cleared in this mutation.
func (m *ReceiptMutation) TaxAmountCleared() bool {
	_, ok := m.clearedFields[receipt.FieldTaxAmount]
	return ok
}

// ResetTaxAmount resets all changes to the "tax_amount" field.
func (m *ReceiptMutation) ResetTaxAmount() {
	m.tax_amount = nil
	m.addtax_amount = nil
	delete(m.clearedFields, receipt.FieldTaxAmount)
}

// SetSubtotalAmount sets the "subtotal_amount" field.
func (m *ReceiptMutation) SetSubtotalAmount(f float64) {
	m.subtotal_amount = &f
	m.addsubtotal_amount = nil
}

// SubtotalAmount returns the value of the "subtotal_amount" field in the mutation.
func (m *ReceiptMutation) SubtotalAmount() (r float64, exists bool) {
	v := m.subtotal_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldSubtotalAmount returns the old "subtotal_amount" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldSubtotalAmount(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubtotalAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubtotalAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubtotalAmount: %w", err)
	}
	return oldValue.SubtotalAmount, nil
}

// AddSubtotalAmount adds f to the "subtotal_amount" field.
func (m *ReceiptMutation) AddSubtotalAmount(f float64) {
	if m.addsubtotal_amount != nil {
		*m.addsubtotal_amount += f
	} else {
		m.addsubtotal_amount = &f
	}
}

// AddedSubtotalAmount returns the value that was added to the "subtotal_amount" field in this mutation.
func (m *ReceiptMutation) AddedSubtotalAmount() (r float64, exists bool) {
	v := m.addsubtotal_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearSubtotalAmount clears the value of the "subtotal_amount" field.
func (m *ReceiptMutation) ClearSubtotalAmount() {
	m.subtotal_amount = nil
	m.addsubtotal_amount = nil
	m.clearedFields[receipt.FieldSubtotalAmount] = struct{}{}
}

// SubtotalAmountCleared returns if the "subtotal_amount" field was cleared in this mutation.
func (m *ReceiptMutation) SubtotalAmountCleared() bool {
	_, ok := m.clearedFields[receipt.FieldSubtotalAmount]
	return ok
}

// ResetSubtotalAmount resets all changes to the "subtotal_amount" field.
func (m *ReceiptMutation) ResetSubtotalAmount() {
	m.subtotal_amount = nil
	m.addsubtotal_amount = nil
	delete(m.clearedFields, receipt.FieldSubtotalAmount)
}

// SetCurrency sets the "currency" field.
func (m *ReceiptMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *ReceiptMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ClearCurrency clears the value of the "currency" field.
func (m *ReceiptMutation) ClearCurrency() {
	m.currency = nil
	m.clearedFields[receipt.FieldCurrency] = struct{}{}
}

// CurrencyCleared returns if the "currency" field was cleared in this mutation.
func (m *ReceiptMutation) CurrencyCleared() bool {
	_, ok := m.clearedFields[receipt.FieldCurrency]
	return ok
}

// ResetCurrency resets all changes to the "currency" field.
func (m *ReceiptMutation) ResetCurrency() {
	m.currency = nil
	delete(m.clearedFields, receipt.FieldCurrency)
}

// SetPaymentMethod sets the "payment_method" field.
func (m *ReceiptMutation) SetPaymentMethod(s string) {
	m.payment_method = &s
}

// PaymentMethod returns the value of the "payment_method" field in the mutation.
func (m *ReceiptMutation) PaymentMethod() (r string, exists bool) {
	v := m.payment_method
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentMethod returns the old "payment_method" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldPaymentMethod(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentMethod: %w", err)
	}
	return oldValue.PaymentMethod, nil
}

// ClearPaymentMethod clears the value of the "payment_method" field.
func (m *ReceiptMutation) ClearPaymentMethod() {
	m.payment_method = nil
	m.clearedFields[receipt.FieldPaymentMethod] = struct{}{}
}

// PaymentMethodCleared returns if the "payment_method" field was cleared in this mutation.
func (m *ReceiptMutation) PaymentMethodCleared() bool {
	_, ok := m.clearedFields[receipt.FieldPaymentMethod]
	return ok
}

// ResetPaymentMethod resets all changes to the "payment_method" field.
func (m *ReceiptMutation) ResetPaymentMethod() {
	m.payment_method = nil
	delete(m.clearedFields, receipt.FieldPaymentMethod)
}

// SetReceiptNumber sets the "receipt_number" field.
func (m *ReceiptMutation) SetReceiptNumber(s string) {
	m.receipt_number = &s
}

// ReceiptNumber returns the value of the "receipt_number" field in the mutation.
func (m *ReceiptMutation) ReceiptNumber() (r string, exists bool) {
	v := m.receipt_number
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiptNumber returns the old "receipt_number" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldReceiptNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiptNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiptNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiptNumber: %w", err)
	}
	return oldValue.ReceiptNumber, nil
}

// ClearReceiptNumber clears the value of the "receipt_number" field.
func (m *ReceiptMutation) ClearReceiptNumber() {
	m.receipt_number = nil
	m.clearedFields[receipt.FieldReceiptNumber] = struct{}{}
}

// ReceiptNumberCleared returns if the "receipt_number" field was cleared in this mutation.
func (m *ReceiptMutation) ReceiptNumberCleared() bool {
	_, ok := m.clearedFields[receipt.FieldReceiptNumber]
	return ok
}

// ResetReceiptNumber resets all changes to the "receipt_number" field.
func (m *ReceiptMutation) ResetReceiptNumber() {
	m.receipt_number = nil
	delete(m.clearedFields, receipt.FieldReceiptNumber)
}

// SetCategoryTags sets the "category_tags" field.
func (m *ReceiptMutation) SetCategoryTags(s []string) {
	m.category_tags = &s
	m.appendcategory_tags = nil
}

// CategoryTags returns the value of the "category_tags" field in the mutation.
func (m *ReceiptMutation) CategoryTags() (r []string, exists bool) {
	v := m.category_tags
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryTags returns the old "category_tags" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldCategoryTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryTags: %w", err)
	}
	return oldValue.CategoryTags, nil
}

// AppendCategoryTags adds s to the "category_tags" field.
func (m *ReceiptMutation) AppendCategoryTags(s []string) {
	m.appendcategory_tags = append(m.appendcategory_tags, s...)
}

// AppendedCategoryTags returns the list of values that were appended to the "category_tags" field in this mutation.
func (m *ReceiptMutation) AppendedCategoryTags() ([]string, bool) {
	if len(m.appendcategory_tags) == 0 {
		return nil, false
	}
	return m.appendcategory_tags, true
}

// ClearCategoryTags clears the value of the "category_tags" field.
func (m *ReceiptMutation) ClearCategoryTags() {
	m.category_tags = nil
	m.appendcategory_tags = nil
	m.clearedFields[receipt.FieldCategoryTags] = struct{}{}
}

// CategoryTagsCleared returns if the "category_tags" field was cleared in this mutation.
func (m *ReceiptMutation) CategoryTagsCleared() bool {
	_, ok := m.clearedFields[receipt.FieldCategoryTags]
	return ok
}

// ResetCategoryTags resets all changes to the "category_tags" field.
func (m *ReceiptMutation) ResetCategoryTags() {
	m.category_tags = nil
	m.appendcategory_tags = nil
	delete(m.clearedFields, receipt.FieldCategoryTags)
}

// SetExtractedData sets the "extracted_data" field.
func (m *ReceiptMutation) SetExtractedData(value map[string]interface{}) {
	m.extracted_data = &value
}

// ExtractedData returns the value of the "extracted_data" field in the mutation.
func (m *ReceiptMutation) ExtractedData() (r map[string]interface{}, exists bool) {
	v := m.extracted_data
	if v == nil {
		return
	}
	return *v, true
}

// OldExtractedData returns the old "extracted_data" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldExtractedData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtractedData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtractedData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtractedData: %w", err)
	}
	return oldValue.ExtractedData, nil
}

// ClearExtractedData clears the value of the "extracted_data" field.
func (m *ReceiptMutation) ClearExtractedData() {
	m.extracted_data = nil
	m.clearedFields[receipt.FieldExtractedData] = struct{}{}
}

// ExtractedDataCleared returns if the "extracted_data" field was cleared in this mutation.
func (m *ReceiptMutation) ExtractedDataCleared() bool {
	_, ok := m.clearedFields[receipt.FieldExtractedData]
	return ok
}

// ResetExtractedData resets all changes to the "extracted_data" field.
func (m *ReceiptMutation) ResetExtractedData() {
	m.extracted_data = nil
	delete(m.clearedFields, receipt.FieldExtractedData)
}

// SetMetadata sets the "metadata" field.
func (m *ReceiptMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ReceiptMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *ReceiptMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[receipt.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *ReceiptMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[receipt.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ReceiptMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, receipt.FieldMetadata)
}

// SetNotes sets the "notes" field.
func (m *ReceiptMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *ReceiptMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *ReceiptMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[receipt.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *ReceiptMutation) NotesCleared() bool {
	_, ok := m.clearedFields[receipt.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *ReceiptMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, receipt.FieldNotes)
}

// SetLegacyID sets the "legacy_id" field.
func (m *ReceiptMutation) SetLegacyID(s string) {
	m.legacy_id = &s
}

// LegacyID returns the value of the "legacy_id" field in the mutation.
func (m *ReceiptMutation) LegacyID() (r string, exists bool) {
	v := m.legacy_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLegacyID returns the old "legacy_id" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldLegacyID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLegacyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLegacyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLegacyID: %w", err)
	}
	return oldValue.LegacyID, nil
}

// ClearLegacyID clears the value of the "legacy_id" field.
func (m *ReceiptMutation) ClearLegacyID() {
	m.legacy_id = nil
	m.clearedFields[receipt.FieldLegacyID] = struct{}{}
}

// LegacyIDCleared returns if the "legacy_id" field was cleared in this mutation.
func (m *ReceiptMutation) LegacyIDCleared() bool {
	_, ok := m.clearedFields[receipt.FieldLegacyID]
	return ok
}

// ResetLegacyID resets all changes to the "legacy_id" field.
func (m *ReceiptMutation) ResetLegacyID() {
	m.legacy_id = nil
	delete(m.clearedFields, receipt.FieldLegacyID)
}

// SetCreatedAt sets the "created_at" field.
func (m *ReceiptMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReceiptMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReceiptMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ReceiptMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ReceiptMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ReceiptMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProcessedAt sets the "processed_at" field.
func (m *ReceiptMutation) SetProcessedAt(t time.Time) {
	m.processed_at = &t
}

// ProcessedAt returns the value of the "processed_at" field in the mutation.
func (m *ReceiptMutation) ProcessedAt() (r time.Time, exists bool) {
	v := m.processed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessedAt returns the old "processed_at" field's value of the Receipt entity.
// If the Receipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReceiptMutation) OldProcessedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessedAt: %w", err)
	}
	return oldValue.ProcessedAt, nil
}

// ClearProcessedAt clears the value of the "processed_at" field.
func (m *ReceiptMutation) ClearProcessedAt() {
	m.processed_at = nil
	m.clearedFields[receipt.FieldProcessedAt] = struct{}{}
}

// ProcessedAtCleared returns if the "processed_at" field was cleared in this mutation.
func (m *ReceiptMutation) ProcessedAtCleared() bool {
	_, ok := m.clearedFields[receipt.FieldProcessedAt]
	return ok
}

// ResetProcessedAt resets all changes to the "processed_at" field.
func (m *ReceiptMutation) ResetProcessedAt() {
	m.processed_at = nil
	delete(m.clearedFields, receipt.FieldProcessedAt)
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by ids.
func (m *ReceiptMutation) AddTransactionIDs(ids ...string) {
	if m.transactions == nil {
		m.transactions = make(map[string]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transaction entity.
func (m *ReceiptMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transaction entity was cleared.
func (m *ReceiptMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transaction entity by IDs.
func (m *ReceiptMutation) RemoveTransactionIDs(ids ...string) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transaction entity.
func (m *ReceiptMutation) RemovedTransactionsIDs() (ids []string) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *ReceiptMutation) TransactionsIDs() (ids []string) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *ReceiptMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// AddLineItemIDs adds the "line_items" edge to the LineItem entity by ids.
func (m *ReceiptMutation) AddLineItemIDs(ids ...string) {
	if m.line_items == nil {
		m.line_items = make(map[string]struct{})
	}
	for i := range ids {
		m.line_items[ids[i]] = struct{}{}
	}
}

// ClearLineItems clears the "line_items" edge to the LineItem entity.
func (m *ReceiptMutation) ClearLineItems() {
	m.clearedline_items = true
}

// LineItemsCleared reports if the "line_items" edge to the LineItem entity was cleared.
func (m *ReceiptMutation) LineItemsCleared() bool {
	return m.clearedline_items
}

// RemoveLineItemIDs removes the "line_items" edge to the LineItem entity by IDs.
func (m *ReceiptMutation) RemoveLineItemIDs(ids ...string) {
	if m.removedline_items == nil {
		m.removedline_items = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.line_items, ids[i])
		m.removedline_items[ids[i]] = struct{}{}
	}
}

// RemovedLineItems returns the removed IDs of the "line_items" edge to the LineItem entity.
func (m *ReceiptMutation) RemovedLineItemsIDs() (ids []string) {
	for id := range m.removedline_items {
		ids = append(ids, id)
	}
	return
}

// LineItemsIDs returns the "line_items" edge IDs in the mutation.
func (m *ReceiptMutation) LineItemsIDs() (ids []string) {
	for id := range m.line_items {
		ids = append(ids, id)
	}
	return
}

// ResetLineItems resets all changes to the "line_items" edge.
func (m *ReceiptMutation) ResetLineItems() {
	m.line_items = nil
	m.clearedline_items = false
	m.removedline_items = nil
}

// Where appends a list predicates to the ReceiptMutation builder.
func (m *ReceiptMutation) Where(ps ...predicate.Receipt) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReceiptMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReceiptMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Receipt, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReceiptMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReceiptMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Receipt).
func (m *ReceiptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReceiptMutation) Fields() []string {
	fields := make([]string, 0, 32)
	if m.user_id != nil {
		fields = append(fields, receipt.FieldUserID)
	}
	if m.source_type != nil {
		fields = append(fields, receipt.FieldSourceType)
	}
	if m.source_id != nil {
		fields = append(fields, receipt.FieldSourceID)
	}
	if m.source_connection_id != nil {
		fields = append(fields, receipt.FieldSourceConnectionID)
	}
	if m.file_name != nil {
		fields = append(fields, receipt.FieldFileName)
	}
	if m.file_path != nil {
		fields = append(fields, receipt.FieldFilePath)
	}
	if m.mime_type != nil {
		fields = append(fields, receipt.FieldMimeType)
	}
	if m.file_size != nil {
		fields = append(fields, receipt.FieldFileSize)
	}
	if m.storage_bucket != nil {
		fields = append(fields, receipt.FieldStorageBucket)
	}
	if m.storage_key != nil {
		fields = append(fields, receipt.FieldStorageKey)
	}
	if m.thumbnail_path != nil {
		fields = append(fields, receipt.FieldThumbnailPath)
	}
	if m.status != nil {
		fields = append(fields, receipt.FieldStatus)
	}
	if m.ocr_completed != nil {
		fields = append(fields, receipt.FieldOcrCompleted)
	}
	if m.ocr_text != nil {
		fields = append(fields, receipt.FieldOcrText)
	}
	if m.ocr_confidence != nil {
		fields = append(fields, receipt.FieldOcrConfidence)
	}
	if m.merchant_name != nil {
		fields = append(fields, receipt.FieldMerchantName)
	}
	if m.merchant_address != nil {
		fields = append(fields, receipt.FieldMerchantAddress)
	}
	if m.receipt_date != nil {
		fields = append(fields, receipt.FieldReceiptDate)
	}
	if m.total_amount != nil {
		fields = append(fields, receipt.FieldTotalAmount)
	}
	if m.tax_amount != nil {
		fields = append(fields, receipt.FieldTaxAmount)
	}
	if m.subtotal_amount != nil {
		fields = append(fields, receipt.FieldSubtotalAmount)
	}
	if m.currency != nil {
		fields = append(fields, receipt.FieldCurrency)
	}
	if m.payment_method != nil {
		fields = append(fields, receipt.FieldPaymentMethod)
	}
	if m.receipt_number != nil {
		fields = append(fields, receipt.FieldReceiptNumber)
	}
	if m.category_tags != nil {
		fields = append(fields, receipt.FieldCategoryTags)
	}
	if m.extracted_data != nil {
		fields = append(fields, receipt.FieldExtractedData)
	}
	if m.metadata != nil {
		fields = append(fields, receipt.FieldMetadata)
	}
	if m.notes != nil {
		fields = append(fields, receipt.FieldNotes)
	}
	if m.legacy_id != nil {
		fields = append(fields, receipt.FieldLegacyID)
	}
	if m.created_at != nil {
		fields = append(fields, receipt.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, receipt.FieldUpdatedAt)
	}
	if m.processed_at != nil {
		fields = append(fields, receipt.FieldProcessedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReceiptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case receipt.FieldUserID:
		return m.UserID()
	case receipt.FieldSourceType:
		return m.SourceType()
	case receipt.FieldSourceID:
		return m.SourceID()
	case receipt.FieldSourceConnectionID:
		return m.SourceConnectionID()
	case receipt.FieldFileName:
		return m.FileName()
	case receipt.FieldFilePath:
		return m.FilePath()
	case receipt.FieldMimeType:
		return m.MimeType()
	case receipt.FieldFileSize:
		return m.FileSize()
	case receipt.FieldStorageBucket:
		return m.StorageBucket()
	case receipt.FieldStorageKey:
		return m.StorageKey()
	case receipt.FieldThumbnailPath:
		return m.ThumbnailPath()
	case receipt.FieldStatus:
		return m.Status()
	case receipt.FieldOcrCompleted:
		return m.OcrCompleted()
	case receipt.FieldOcrText:
		return m.OcrText()
	case receipt.FieldOcrConfidence:
		return m.OcrConfidence()
	case receipt.FieldMerchantName:
		return m.MerchantName()
	case receipt.FieldMerchantAddress:
		return m.MerchantAddress()
	case receipt.FieldReceiptDate:
		return m.ReceiptDate()
	case receipt.FieldTotalAmount:
		return m.TotalAmount()
	case receipt.FieldTaxAmount:
		return m.TaxAmount()
	case receipt.FieldSubtotalAmount:
		return m.SubtotalAmount()
	case receipt.FieldCurrency:
		return m.Currency()
	case receipt.FieldPaymentMethod:
		return m.PaymentMethod()
	case receipt.FieldReceiptNumber:
		return m.ReceiptNumber()
	case receipt.FieldCategoryTags:
		return m.CategoryTags()
	case receipt.FieldExtractedData:
		return m.ExtractedData()
	case receipt.FieldMetadata:
		return m.Metadata()
	case receipt.FieldNotes:
		return m.Notes()
	case receipt.FieldLegacyID:
		return m.LegacyID()
	case receipt.FieldCreatedAt:
		return m.CreatedAt()
	case receipt.FieldUpdatedAt:
		return m.UpdatedAt()
	case receipt.FieldProcessedAt:
		return m.ProcessedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReceiptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case receipt.FieldUserID:
		return m.OldUserID(ctx)
	case receipt.FieldSourceType:
		return m.OldSourceType(ctx)
	case receipt.FieldSourceID:
		return m.OldSourceID(ctx)
	case receipt.FieldSourceConnectionID:
		return m.OldSourceConnectionID(ctx)
	case receipt.FieldFileName:
		return m.OldFileName(ctx)
	case receipt.FieldFilePath:
		return m.OldFilePath(ctx)
	case receipt.FieldMimeType:
		return m.OldMimeType(ctx)
	case receipt.FieldFileSize:
		return m.OldFileSize(ctx)
	case receipt.FieldStorageBucket:
		return m.OldStorageBucket(ctx)
	case receipt.FieldStorageKey:
		return m.OldStorageKey(ctx)
	case receipt.FieldThumbnailPath:
		return m.OldThumbnailPath(ctx)
	case receipt.FieldStatus:
		return m.OldStatus(ctx)
	case receipt.FieldOcrCompleted:
		return m.OldOcrCompleted(ctx)
	case receipt.FieldOcrText:
		return m.OldOcrText(ctx)
	case receipt.FieldOcrConfidence:
		return m.OldOcrConfidence(ctx)
	case receipt.FieldMerchantName:
		return m.OldMerchantName(ctx)
	case receipt.FieldMerchantAddress:
		return m.OldMerchantAddress(ctx)
	case receipt.FieldReceiptDate:
		return m.OldReceiptDate(ctx)
	case receipt.FieldTotalAmount:
		return m.OldTotalAmount(ctx)
	case receipt.FieldTaxAmount:
		return m.OldTaxAmount(ctx)
	case receipt.FieldSubtotalAmount:
		return m.OldSubtotalAmount(ctx)
	case receipt.FieldCurrency:
		return m.OldCurrency(ctx)
	case receipt.FieldPaymentMethod:
		return m.OldPaymentMethod(ctx)
	case receipt.FieldReceiptNumber:
		return m.OldReceiptNumber(ctx)
	case receipt.FieldCategoryTags:
		return m.OldCategoryTags(ctx)
	case receipt.FieldExtractedData:
		return m.OldExtractedData(ctx)
	case receipt.FieldMetadata:
		return m.OldMetadata(ctx)
	case receipt.FieldNotes:
		return m.OldNotes(ctx)
	case receipt.FieldLegacyID:
		return m.OldLegacyID(ctx)
	case receipt.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case receipt.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case receipt.FieldProcessedAt:
		return m.OldProcessedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Receipt field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReceiptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case receipt.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case receipt.FieldSourceType:
		v, ok := value.(receipt.SourceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceType(v)
		return nil
	case receipt.FieldSourceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	case receipt.FieldSourceConnectionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceConnectionID(v)
		return nil
	case receipt.FieldFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileName(v)
		return nil
	case receipt.FieldFilePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilePath(v)
		return nil
	case receipt.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	case receipt.FieldFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileSize(v)
		return nil
	case receipt.FieldStorageBucket:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageBucket(v)
		return nil
	case receipt.FieldStorageKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageKey(v)
		return nil
	case receipt.FieldThumbnailPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailPath(v)
		return nil
	case receipt.FieldStatus:
		v, ok := value.(receipt.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case receipt.FieldOcrCompleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOcrCompleted(v)
		return nil
	case receipt.FieldOcrText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOcrText(v)
		return nil
	case receipt.FieldOcrConfidence:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOcrConfidence(v)
		return nil
	case receipt.FieldMerchantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantName(v)
		return nil
	case receipt.FieldMerchantAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantAddress(v)
		return nil
	case receipt.FieldReceiptDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiptDate(v)
		return nil
	case receipt.FieldTotalAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalAmount(v)
		return nil
	case receipt.FieldTaxAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxAmount(v)
		return nil
	case receipt.FieldSubtotalAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubtotalAmount(v)
		return nil
	case receipt.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case receipt.FieldPaymentMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentMethod(v)
		return nil
	case receipt.FieldReceiptNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiptNumber(v)
		return nil
	case receipt.FieldCategoryTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryTags(v)
		return nil
	case receipt.FieldExtractedData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtractedData(v)
		return nil
	case receipt.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case receipt.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case receipt.FieldLegacyID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLegacyID(v)
		return nil
	case receipt.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case receipt.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case receipt.FieldProcessedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Receipt field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReceiptMutation) AddedFields() []string {
	var fields []string
	if m.addfile_size != nil {
		fields = append(fields, receipt.FieldFileSize)
	}
	if m.addocr_confidence != nil {
		fields = append(fields, receipt.FieldOcrConfidence)
	}
	if m.addtotal_amount != nil {
		fields = append(fields, receipt.FieldTotalAmount)
	}
	if m.addtax_amount != nil {
		fields = append(fields, receipt.FieldTaxAmount)
	}
	if m.addsubtotal_amount != nil {
		fields = append(fields, receipt.FieldSubtotalAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReceiptMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case receipt.FieldFileSize:
		return m.AddedFileSize()
	case receipt.FieldOcrConfidence:
		return m.AddedOcrConfidence()
	case receipt.FieldTotalAmount:
		return m.AddedTotalAmount()
	case receipt.FieldTaxAmount:
		return m.AddedTaxAmount()
	case receipt.FieldSubtotalAmount:
		return m.AddedSubtotalAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReceiptMutation) AddField(name string, value ent.Value) error {
	switch name {
	case receipt.FieldFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileSize(v)
		return nil
	case receipt.FieldOcrConfidence:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOcrConfidence(v)
		return nil
	case receipt.FieldTotalAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalAmount(v)
		return nil
	case receipt.FieldTaxAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaxAmount(v)
		return nil
	case receipt.FieldSubtotalAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSubtotalAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Receipt numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReceiptMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(receipt.FieldSourceID) {
		fields = append(fields, receipt.FieldSourceID)
	}
	if m.FieldCleared(receipt.FieldSourceConnectionID) {
		fields = append(fields, receipt.FieldSourceConnectionID)
	}
	if m.FieldCleared(receipt.FieldFilePath) {
		fields = append(fields, receipt.FieldFilePath)
	}
	if m.FieldCleared(receipt.FieldStorageBucket) {
		fields = append(fields, receipt.FieldStorageBucket)
	}
	if m.FieldCleared(receipt.FieldStorageKey) {
		fields = append(fields, receipt.FieldStorageKey)
	}
	if m.FieldCleared(receipt.FieldThumbnailPath) {
		fields = append(fields, receipt.FieldThumbnailPath)
	}
	if m.FieldCleared(receipt.FieldOcrText) {
		fields = append(fields, receipt.FieldOcrText)
	}
	if m.FieldCleared(receipt.FieldOcrConfidence) {
		fields = append(fields, receipt.FieldOcrConfidence)
	}
	if m.FieldCleared(receipt.FieldMerchantName) {
		fields = append(fields, receipt.FieldMerchantName)
	}
	if m.FieldCleared(receipt.FieldMerchantAddress) {
		fields = append(fields, receipt.FieldMerchantAddress)
	}
	if m.FieldCleared(receipt.FieldReceiptDate) {
		fields = append(fields, receipt.FieldReceiptDate)
	}
	if m.FieldCleared(receipt.FieldTotalAmount) {
		fields = append(fields, receipt.FieldTotalAmount)
	}
	if m.FieldCleared(receipt.FieldTaxAmount) {
		fields = append(fields, receipt.FieldTaxAmount)
	}
	if m.FieldCleared(receipt.FieldSubtotalAmount) {
		fields = append(fields, receipt.FieldSubtotalAmount)
	}
	if m.FieldCleared(receipt.FieldCurrency) {
		fields = append(fields, receipt.FieldCurrency)
	}
	if m.FieldCleared(receipt.FieldPaymentMethod) {
		fields = append(fields, receipt.FieldPaymentMethod)
	}
	if m.FieldCleared(receipt.FieldReceiptNumber) {
		fields = append(fields, receipt.FieldReceiptNumber)
	}
	if m.FieldCleared(receipt.FieldCategoryTags) {
		fields = append(fields, receipt.FieldCategoryTags)
	}
	if m.FieldCleared(receipt.FieldExtractedData) {
		fields = append(fields, receipt.FieldExtractedData)
	}
	if m.FieldCleared(receipt.FieldMetadata) {
		fields = append(fields, receipt.FieldMetadata)
	}
	if m.FieldCleared(receipt.FieldNotes) {
		fields = append(fields, receipt.FieldNotes)
	}
	if m.FieldCleared(receipt.FieldLegacyID) {
		fields = append(fields, receipt.FieldLegacyID)
	}
	if m.FieldCleared(receipt.FieldProcessedAt) {
		fields = append(fields, receipt.FieldProcessedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReceiptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReceiptMutation) ClearField(name string) error {
	switch name {
	case receipt.FieldSourceID:
		m.ClearSourceID()
		return nil
	case receipt.FieldSourceConnectionID:
		m.ClearSourceConnectionID()
		return nil
	case receipt.FieldFilePath:
		m.ClearFilePath()
		return nil
	case receipt.FieldStorageBucket:
		m.ClearStorageBucket()
		return nil
	case receipt.FieldStorageKey:
		m.ClearStorageKey()
		return nil
	case receipt.FieldThumbnailPath:
		m.ClearThumbnailPath()
		return nil
	case receipt.FieldOcrText:
		m.ClearOcrText()
		return nil
	case receipt.FieldOcrConfidence:
		m.ClearOcrConfidence()
		return nil
	case receipt.FieldMerchantName:
		m.ClearMerchantName()
		return nil
	case receipt.FieldMerchantAddress:
		m.ClearMerchantAddress()
		return nil
	case receipt.FieldReceiptDate:
		m.ClearReceiptDate()
		return nil
	case receipt.FieldTotalAmount:
		m.ClearTotalAmount()
		return nil
	case receipt.FieldTaxAmount:
		m.ClearTaxAmount()
		return nil
	case receipt.FieldSubtotalAmount:
		m.ClearSubtotalAmount()
		return nil
	case receipt.FieldCurrency:
		m.ClearCurrency()
		return nil
	case receipt.FieldPaymentMethod:
		m.ClearPaymentMethod()
		return nil
	case receipt.FieldReceiptNumber:
		m.ClearReceiptNumber()
		return nil
	case receipt.FieldCategoryTags:
		m.ClearCategoryTags()
		return nil
	case receipt.FieldExtractedData:
		m.ClearExtractedData()
		return nil
	case receipt.FieldMetadata:
		m.ClearMetadata()
		return nil
	case receipt.FieldNotes:
		m.ClearNotes()
		return nil
	case receipt.FieldLegacyID:
		m.ClearLegacyID()
		return nil
	case receipt.FieldProcessedAt:
		m.ClearProcessedAt()
		return nil
	}
	return fmt.Errorf("unknown Receipt nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReceiptMutation) ResetField(name string) error {
	switch name {
	case receipt.FieldUserID:
		m.ResetUserID()
		return nil
	case receipt.FieldSourceType:
		m.ResetSourceType()
		return nil
	case receipt.FieldSourceID:
		m.ResetSourceID()
		return nil
	case receipt.FieldSourceConnectionID:
		m.ResetSourceConnectionID()
		return nil
	case receipt.FieldFileName:
		m.ResetFileName()
		return nil
	case receipt.FieldFilePath:
		m.ResetFilePath()
		return nil
	case receipt.FieldMimeType:
		m.ResetMimeType()
		return nil
	case receipt.FieldFileSize:
		m.ResetFileSize()
		return nil
	case receipt.FieldStorageBucket:
		m.ResetStorageBucket()
		return nil
	case receipt.FieldStorageKey:
		m.ResetStorageKey()
		return nil
	case receipt.FieldThumbnailPath:
		m.ResetThumbnailPath()
		return nil
	case receipt.FieldStatus:
		m.ResetStatus()
		return nil
	case receipt.FieldOcrCompleted:
		m.ResetOcrCompleted()
		return nil
	case receipt.FieldOcrText:
		m.ResetOcrText()
		return nil
	case receipt.FieldOcrConfidence:
		m.ResetOcrConfidence()
		return nil
	case receipt.FieldMerchantName:
		m.ResetMerchantName()
		return nil
	case receipt.FieldMerchantAddress:
		m.ResetMerchantAddress()
		return nil
	case receipt.FieldReceiptDate:
		m.ResetReceiptDate()
		return nil
	case receipt.FieldTotalAmount:
		m.ResetTotalAmount()
		return nil
	case receipt.FieldTaxAmount:
		m.ResetTaxAmount()
		return nil
	case receipt.FieldSubtotalAmount:
		m.ResetSubtotalAmount()
		return nil
	case receipt.FieldCurrency:
		m.ResetCurrency()
		return nil
	case receipt.FieldPaymentMethod:
		m.ResetPaymentMethod()
		return nil
	case receipt.FieldReceiptNumber:
		m.ResetReceiptNumber()
		return nil
	case receipt.FieldCategoryTags:
		m.ResetCategoryTags()
		return nil
	case receipt.FieldExtractedData:
		m.ResetExtractedData()
		return nil
	case receipt.FieldMetadata:
		m.ResetMetadata()
		return nil
	case receipt.FieldNotes:
		m.ResetNotes()
		return nil
	case receipt.FieldLegacyID:
		m.ResetLegacyID()
		return nil
	case receipt.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case receipt.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case receipt.FieldProcessedAt:
		m.ResetProcessedAt()
		return nil
	}
	return fmt.Errorf("unknown Receipt field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReceiptMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.transactions != nil {
		edges = append(edges, receipt.EdgeTransactions)
	}
	if m.line_items != nil {
		edges = append(edges, receipt.EdgeLineItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReceiptMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case receipt.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	case receipt.EdgeLineItems:
		ids := make([]ent.Value, 0, len(m.line_items))
		for id := range m.line_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReceiptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtransactions != nil {
		edges = append(edges, receipt.EdgeTransactions)
	}
	if m.removedline_items != nil {
		edges = append(edges, receipt.EdgeLineItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReceiptMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case receipt.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	case receipt.EdgeLineItems:
		ids := make([]ent.Value, 0, len(m.removedline_items))
		for id := range m.removedline_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReceiptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtransactions {
		edges = append(edges, receipt.EdgeTransactions)
	}
	if m.clearedline_items {
		edges = append(edges, receipt.EdgeLineItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReceiptMutation) EdgeCleared(name string) bool {
	switch name {
	case receipt.EdgeTransactions:
		return m.clearedtransactions
	case receipt.EdgeLineItems:
		return m.clearedline_items
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReceiptMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Receipt unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReceiptMutation) ResetEdge(name string) error {
	switch name {
	case receipt.EdgeTransactions:
		m.ResetTransactions()
		return nil
	case receipt.EdgeLineItems:
		m.ResetLineItems()
		return nil
	}
	return fmt.Errorf("unknown Receipt edge %s", name)
}

// TransactionMutation represents an operation that mutates the Transaction nodes in the graph.
type TransactionMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	user_id             *string
	_type               *transaction.Type
	amount              *float64
	addamount           *float64
	currency            *string
	transaction_date    *time.Time
	description         *string
	merchant_name       *string
	merchant_category   *string
	payment_method      *string
	card_last_four      *string
	reference_number    *string
	authorization_code  *string
	status              *transaction.Status
	is_recurring        *bool
	recurrence_pattern  *string
	category_tags       *[]string
	appendcategory_tags []string
	metadata            *map[string]interface{}
	notes               *string
	legacy_id           *string
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	receipt             *string
	clearedreceipt      bool
	done                bool
	oldValue            func(context.Context) (*Transaction, error)
	predicates          []predicate.Transaction
}

var _ ent.Mutation = (*TransactionMutation)(nil)

// transactionOption allows management of the mutation configuration using functional options.
type transactionOption func(*TransactionMutation)

// newTransactionMutation creates new mutation for the Transaction entity.
func newTransactionMutation(c config, op Op, opts ...transactionOption) *TransactionMutation {
	m := &TransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionID sets the ID field of the mutation.
func withTransactionID(id string) transactionOption {
	return func(m *TransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *Transaction
		)
		m.oldValue = func(ctx context.Context) (*Transaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransaction sets the old Transaction of the mutation.
func withTransaction(node *Transaction) transactionOption {
	return func(m *TransactionMutation) {
		m.oldValue = func(context.Context) (*Transaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Transaction entities.
func (m *TransactionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReceiptID sets the "receipt_id" field.
func (m *TransactionMutation) SetReceiptID(s string) {
	m.receipt = &s
}

// ReceiptID returns the value of the "receipt_id" field in the mutation.
func (m *TransactionMutation) ReceiptID() (r string, exists bool) {
	v := m.receipt
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiptID returns the old "receipt_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldReceiptID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiptID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiptID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiptID: %w", err)
	}
	return oldValue.ReceiptID, nil
}

// ResetReceiptID resets all changes to the "receipt_id" field.
func (m *TransactionMutation) ResetReceiptID() {
	m.receipt = nil
}

// SetUserID sets the "user_id" field.
func (m *TransactionMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TransactionMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TransactionMutation) ResetUserID() {
	m.user_id = nil
}

// SetType sets the "type" field.
func (m *TransactionMutation) SetType(t transaction.Type) {
	m._type = &t
}

// GetType returns the value of the "type" field in the mutation.
func (m *TransactionMutation) GetType() (r transaction.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldType(ctx context.Context) (v transaction.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TransactionMutation) ResetType() {
	m._type = nil
}

// SetAmount sets the "amount" field.
func (m *TransactionMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *TransactionMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *TransactionMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *TransactionMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *TransactionMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetCurrency sets the "currency" field.
func (m *TransactionMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *TransactionMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *TransactionMutation) ResetCurrency() {
	m.currency = nil
}

// SetTransactionDate sets the "transaction_date" field.
func (m *TransactionMutation) SetTransactionDate(t time.Time) {
	m.transaction_date = &t
}

// TransactionDate returns the value of the "transaction_date" field in the mutation.
func (m *TransactionMutation) TransactionDate() (r time.Time, exists bool) {
	v := m.transaction_date
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionDate returns the old "transaction_date" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldTransactionDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionDate: %w", err)
	}
	return oldValue.TransactionDate, nil
}

// ResetTransactionDate resets all changes to the "transaction_date" field.
func (m *TransactionMutation) ResetTransactionDate() {
	m.transaction_date = nil
}

// SetDescription sets the "description" field.
func (m *TransactionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TransactionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TransactionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[transaction.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TransactionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[transaction.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TransactionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, transaction.FieldDescription)
}

// SetMerchantName sets the "merchant_name" field.
func (m *TransactionMutation) SetMerchantName(s string) {
	m.merchant_name = &s
}

// MerchantName returns the value of the "merchant_name" field in the mutation.
func (m *TransactionMutation) MerchantName() (r string, exists bool) {
	v := m.merchant_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantName returns the old "merchant_name" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldMerchantName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantName: %w", err)
	}
	return oldValue.MerchantName, nil
}

// ClearMerchantName clears the value of the "merchant_name" field.
func (m *TransactionMutation) ClearMerchantName() {
	m.merchant_name = nil
	m.clearedFields[transaction.FieldMerchantName] = struct{}{}
}

// MerchantNameCleared returns if the "merchant_name" field was cleared in this mutation.
func (m *TransactionMutation) MerchantNameCleared() bool {
	_, ok := m.clearedFields[transaction.FieldMerchantName]
	return ok
}

// ResetMerchantName resets all changes to the "merchant_name" field.
func (m *TransactionMutation) ResetMerchantName() {
	m.merchant_name = nil
	delete(m.clearedFields, transaction.FieldMerchantName)
}

// SetMerchantCategory sets the "merchant_category" field.
func (m *TransactionMutation) SetMerchantCategory(s string) {
	m.merchant_category = &s
}

// MerchantCategory returns the value of the "merchant_category" field in the mutation.
func (m *TransactionMutation) MerchantCategory() (r string, exists bool) {
	v := m.merchant_category
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantCategory returns the old "merchant_category" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldMerchantCategory(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantCategory: %w", err)
	}
	return oldValue.MerchantCategory, nil
}

// ClearMerchantCategory clears the value of the "merchant_category" field.
func (m *TransactionMutation) ClearMerchantCategory() {
	m.merchant_category = nil
	m.clearedFields[transaction.FieldMerchantCategory] = struct{}{}
}

// MerchantCategoryCleared returns if the "merchant_category" field was cleared in this mutation.
func (m *TransactionMutation) MerchantCategoryCleared() bool {
	_, ok := m.clearedFields[transaction.FieldMerchantCategory]
	return ok
}

// ResetMerchantCategory resets all changes to the "merchant_category" field.
func (m *TransactionMutation) ResetMerchantCategory() {
	m.merchant_category = nil
	delete(m.clearedFields, transaction.FieldMerchantCategory)
}

// SetPaymentMethod sets the "payment_method" field.
func (m *TransactionMutation) SetPaymentMethod(s string) {
	m.payment_method = &s
}

// PaymentMethod returns the value of the "payment_method" field in the mutation.
func (m *TransactionMutation) PaymentMethod() (r string, exists bool) {
	v := m.payment_method
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentMethod returns the old "payment_method" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldPaymentMethod(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentMethod: %w", err)
	}
	return oldValue.PaymentMethod, nil
}

// ClearPaymentMethod clears the value of the "payment_method" field.
func (m *TransactionMutation) ClearPaymentMethod() {
	m.payment_method = nil
	m.clearedFields[transaction.FieldPaymentMethod] = struct{}{}
}

// PaymentMethodCleared returns if the "payment_method" field was cleared in this mutation.
func (m *TransactionMutation) PaymentMethodCleared() bool {
	_, ok := m.clearedFields[transaction.FieldPaymentMethod]
	return ok
}

// ResetPaymentMethod resets all changes to the "payment_method" field.
func (m *TransactionMutation) ResetPaymentMethod() {
	m.payment_method = nil
	delete(m.clearedFields, transaction.FieldPaymentMethod)
}

// SetCardLastFour sets the "card_last_four" field.
func (m *TransactionMutation) SetCardLastFour(s string) {
	m.card_last_four = &s
}

// CardLastFour returns the value of the "card_last_four" field in the mutation.
func (m *TransactionMutation) CardLastFour() (r string, exists bool) {
	v := m.card_last_four
	if v == nil {
		return
	}
	return *v, true
}

// OldCardLastFour returns the old "card_last_four" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldCardLastFour(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCardLastFour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCardLastFour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCardLastFour: %w", err)
	}
	return oldValue.CardLastFour, nil
}

// ClearCardLastFour clears the value of the "card_last_four" field.
func (m *TransactionMutation) ClearCardLastFour() {
	m.card_last_four = nil
	m.clearedFields[transaction.FieldCardLastFour] = struct{}{}
}

// CardLastFourCleared returns if the "card_last_four" field was cleared in this mutation.
func (m *TransactionMutation) CardLastFourCleared() bool {
	_, ok := m.clearedFields[transaction.FieldCardLastFour]
	return ok
}

// ResetCardLastFour resets all changes to the "card_last_four" field.
func (m *TransactionMutation) ResetCardLastFour() {
	m.card_last_four = nil
	delete(m.clearedFields, transaction.FieldCardLastFour)
}

// SetReferenceNumber sets the "reference_number" field.
func (m *TransactionMutation) SetReferenceNumber(s string) {
	m.reference_number = &s
}

// ReferenceNumber returns the value of the "reference_number" field in the mutation.
func (m *TransactionMutation) ReferenceNumber() (r string, exists bool) {
	v := m.reference_number
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceNumber returns the old "reference_number" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldReferenceNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceNumber: %w", err)
	}
	return oldValue.ReferenceNumber, nil
}

// ClearReferenceNumber clears the value of the "reference_number" field.
func (m *TransactionMutation) ClearReferenceNumber() {
	m.reference_number = nil
	m.clearedFields[transaction.FieldReferenceNumber] = struct{}{}
}

// ReferenceNumberCleared returns if the "reference_number" field was cleared in this mutation.
func (m *TransactionMutation) ReferenceNumberCleared() bool {
	_, ok := m.clearedFields[transaction.FieldReferenceNumber]
	return ok
}

// ResetReferenceNumber resets all changes to the "reference_number" field.
func (m *TransactionMutation) ResetReferenceNumber() {
	m.reference_number = nil
	delete(m.clearedFields, transaction.FieldReferenceNumber)
}

// SetAuthorizationCode sets the "authorization_code" field.
func (m *TransactionMutation) SetAuthorizationCode(s string) {
	m.authorization_code = &s
}

// AuthorizationCode returns the value of the "authorization_code" field in the mutation.
func (m *TransactionMutation) AuthorizationCode() (r string, exists bool) {
	v := m.authorization_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorizationCode returns the old "authorization_code" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldAuthorizationCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorizationCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorizationCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorizationCode: %w", err)
	}
	return oldValue.AuthorizationCode, nil
}

// ClearAuthorizationCode clears the value of the "authorization_code" field.
func (m *TransactionMutation) ClearAuthorizationCode() {
	m.authorization_code = nil
	m.clearedFields[transaction.FieldAuthorizationCode] = struct{}{}
}

// AuthorizationCodeCleared returns if the "authorization_code" field was cleared in this mutation.
func (m *TransactionMutation) AuthorizationCodeCleared() bool {
	_, ok := m.clearedFields[transaction.FieldAuthorizationCode]
	return ok
}

// ResetAuthorizationCode resets all changes to the "authorization_code" field.
func (m *TransactionMutation) ResetAuthorizationCode() {
	m.authorization_code = nil
	delete(m.clearedFields, transaction.FieldAuthorizationCode)
}

// SetStatus sets the "status" field.
func (m *TransactionMutation) SetStatus(t transaction.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TransactionMutation) Status() (r transaction.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldStatus(ctx context.Context) (v transaction.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TransactionMutation) ResetStatus() {
	m.status = nil
}

// SetIsRecurring sets the "is_recurring" field.
func (m *TransactionMutation) SetIsRecurring(b bool) {
	m.is_recurring = &b
}

// IsRecurring returns the value of the "is_recurring" field in the mutation.
func (m *TransactionMutation) IsRecurring() (r bool, exists bool) {
	v := m.is_recurring
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRecurring returns the old "is_recurring" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldIsRecurring(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRecurring is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRecurring requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRecurring: %w", err)
	}
	return oldValue.IsRecurring, nil
}

// ResetIsRecurring resets all changes to the "is_recurring" field.
func (m *TransactionMutation) ResetIsRecurring() {
	m.is_recurring = nil
}

// SetRecurrencePattern sets the "recurrence_pattern" field.
func (m *TransactionMutation) SetRecurrencePattern(s string) {
	m.recurrence_pattern = &s
}

// RecurrencePattern returns the value of the "recurrence_pattern" field in the mutation.
func (m *TransactionMutation) RecurrencePattern() (r string, exists bool) {
	v := m.recurrence_pattern
	if v == nil {
		return
	}
	return *v, true
}

// OldRecurrencePattern returns the old "recurrence_pattern" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldRecurrencePattern(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecurrencePattern is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecurrencePattern requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecurrencePattern: %w", err)
	}
	return oldValue.RecurrencePattern, nil
}

// ClearRecurrencePattern clears the value of the "recurrence_pattern" field.
func (m *TransactionMutation) ClearRecurrencePattern() {
	m.recurrence_pattern = nil
	m.clearedFields[transaction.FieldRecurrencePattern] = struct{}{}
}

// RecurrencePatternCleared returns if the "recurrence_pattern" field was cleared in this mutation.
func (m *TransactionMutation) RecurrencePatternCleared() bool {
	_, ok := m.clearedFields[transaction.FieldRecurrencePattern]
	return ok
}

// ResetRecurrencePattern resets all changes to the "recurrence_pattern" field.
func (m *TransactionMutation) ResetRecurrencePattern() {
	m.recurrence_pattern = nil
	delete(m.clearedFields, transaction.FieldRecurrencePattern)
}

// SetCategoryTags sets the "category_tags" field.
func (m *TransactionMutation) SetCategoryTags(s []string) {
	m.category_tags = &s
	m.appendcategory_tags = nil
}

// CategoryTags returns the value of the "category_tags" field in the mutation.
func (m *TransactionMutation) CategoryTags() (r []string, exists bool) {
	v := m.category_tags
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryTags returns the old "category_tags" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldCategoryTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryTags: %w", err)
	}
	return oldValue.CategoryTags, nil
}

// AppendCategoryTags adds s to the "category_tags" field.
func (m *TransactionMutation) AppendCategoryTags(s []string) {
	m.appendcategory_tags = append(m.appendcategory_tags, s...)
}

// AppendedCategoryTags returns the list of values that were appended to the "category_tags" field in this mutation.
func (m *TransactionMutation) AppendedCategoryTags() ([]string, bool) {
	if len(m.appendcategory_tags) == 0 {
		return nil, false
	}
	return m.appendcategory_tags, true
}

// ClearCategoryTags clears the value of the "category_tags" field.
func (m *TransactionMutation) ClearCategoryTags() {
	m.category_tags = nil
	m.appendcategory_tags = nil
	m.clearedFields[transaction.FieldCategoryTags] = struct{}{}
}

// CategoryTagsCleared returns if the "category_tags" field was cleared in this mutation.
func (m *TransactionMutation) CategoryTagsCleared() bool {
	_, ok := m.clearedFields[transaction.FieldCategoryTags]
	return ok
}

// ResetCategoryTags resets all changes to the "category_tags" field.
func (m *TransactionMutation) ResetCategoryTags() {
	m.category_tags = nil
	m.appendcategory_tags = nil
	delete(m.clearedFields, transaction.FieldCategoryTags)
}

// SetMetadata sets the "metadata" field.
func (m *TransactionMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *TransactionMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *TransactionMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[transaction.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *TransactionMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[transaction.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *TransactionMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, transaction.FieldMetadata)
}

// SetNotes sets the "notes" field.
func (m *TransactionMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *TransactionMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *TransactionMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[transaction.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *TransactionMutation) NotesCleared() bool {
	_, ok := m.clearedFields[transaction.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *TransactionMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, transaction.FieldNotes)
}

// SetLegacyID sets the "legacy_id" field.
func (m *TransactionMutation) SetLegacyID(s string) {
	m.legacy_id = &s
}

// LegacyID returns the value of the "legacy_id" field in the mutation.
func (m *TransactionMutation) LegacyID() (r string, exists bool) {
	v := m.legacy_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLegacyID returns the old "legacy_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldLegacyID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLegacyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLegacyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLegacyID: %w", err)
	}
	return oldValue.LegacyID, nil
}

// ClearLegacyID clears the value of the "legacy_id" field.
func (m *TransactionMutation) ClearLegacyID() {
	m.legacy_id = nil
	m.clearedFields[transaction.FieldLegacyID] = struct{}{}
}

// LegacyIDCleared returns if the "legacy_id" field was cleared in this mutation.
func (m *TransactionMutation) LegacyIDCleared() bool {
	_, ok := m.clearedFields[transaction.FieldLegacyID]
	return ok
}

// ResetLegacyID resets all changes to the "legacy_id" field.
func (m *TransactionMutation) ResetLegacyID() {
	m.legacy_id = nil
	delete(m.clearedFields, transaction.FieldLegacyID)
}

// SetCreatedAt sets the "created_at" field.
func (m *TransactionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TransactionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TransactionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TransactionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TransactionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TransactionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearReceipt clears the "receipt" edge to the Receipt entity.
func (m *TransactionMutation) ClearReceipt() {
	m.clearedreceipt = true
	m.clearedFields[transaction.FieldReceiptID] = struct{}{}
}

// ReceiptCleared reports if the "receipt" edge to the Receipt entity was cleared.
func (m *TransactionMutation) ReceiptCleared() bool {
	return m.clearedreceipt
}

// ReceiptIDs returns the "receipt" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReceiptID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) ReceiptIDs() (ids []string) {
	if id := m.receipt; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReceipt resets all changes to the "receipt" edge.
func (m *TransactionMutation) ResetReceipt() {
	m.receipt = nil
	m.clearedreceipt = false
}

// Where appends a list predicates to the TransactionMutation builder.
func (m *TransactionMutation) Where(ps ...predicate.Transaction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransactionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransactionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Transaction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransactionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransactionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Transaction).
func (m *TransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.receipt != nil {
		fields = append(fields, transaction.FieldReceiptID)
	}
	if m.user_id != nil {
		fields = append(fields, transaction.FieldUserID)
	}
	if m._type != nil {
		fields = append(fields, transaction.FieldType)
	}
	if m.amount != nil {
		fields = append(fields, transaction.FieldAmount)
	}
	if m.currency != nil {
		fields = append(fields, transaction.FieldCurrency)
	}
	if m.transaction_date != nil {
		fields = append(fields, transaction.FieldTransactionDate)
	}
	if m.description != nil {
		fields = append(fields, transaction.FieldDescription)
	}
	if m.merchant_name != nil {
		fields = append(fields, transaction.FieldMerchantName)
	}
	if m.merchant_category != nil {
		fields = append(fields, transaction.FieldMerchantCategory)
	}
	if m.payment_method != nil {
		fields = append(fields, transaction.FieldPaymentMethod)
	}
	if m.card_last_four != nil {
		fields = append(fields, transaction.FieldCardLastFour)
	}
	if m.reference_number != nil {
		fields = append(fields, transaction.FieldReferenceNumber)
	}
	if m.authorization_code != nil {
		fields = append(fields, transaction.FieldAuthorizationCode)
	}
	if m.status != nil {
		fields = append(fields, transaction.FieldStatus)
	}
	if m.is_recurring != nil {
		fields = append(fields, transaction.FieldIsRecurring)
	}
	if m.recurrence_pattern != nil {
		fields = append(fields, transaction.FieldRecurrencePattern)
	}
	if m.category_tags != nil {
		fields = append(fields, transaction.FieldCategoryTags)
	}
	if m.metadata != nil {
		fields = append(fields, transaction.FieldMetadata)
	}
	if m.notes != nil {
		fields = append(fields, transaction.FieldNotes)
	}
	if m.legacy_id != nil {
		fields = append(fields, transaction.FieldLegacyID)
	}
	if m.created_at != nil {
		fields = append(fields, transaction.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, transaction.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldReceiptID:
		return m.ReceiptID()
	case transaction.FieldUserID:
		return m.UserID()
	case transaction.FieldType:
		return m.GetType()
	case transaction.FieldAmount:
		return m.Amount()
	case transaction.FieldCurrency:
		return m.Currency()
	case transaction.FieldTransactionDate:
		return m.TransactionDate()
	case transaction.FieldDescription:
		return m.Description()
	case transaction.FieldMerchantName:
		return m.MerchantName()
	case transaction.FieldMerchantCategory:
		return m.MerchantCategory()
	case transaction.FieldPaymentMethod:
		return m.PaymentMethod()
	case transaction.FieldCardLastFour:
		return m.CardLastFour()
	case transaction.FieldReferenceNumber:
		return m.ReferenceNumber()
	case transaction.FieldAuthorizationCode:
		return m.AuthorizationCode()
	case transaction.FieldStatus:
		return m.Status()
	case transaction.FieldIsRecurring:
		return m.IsRecurring()
	case transaction.FieldRecurrencePattern:
		return m.RecurrencePattern()
	case transaction.FieldCategoryTags:
		return m.CategoryTags()
	case transaction.FieldMetadata:
		return m.Metadata()
	case transaction.FieldNotes:
		return m.Notes()
	case transaction.FieldLegacyID:
		return m.LegacyID()
	case transaction.FieldCreatedAt:
		return m.CreatedAt()
	case transaction.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transaction.FieldReceiptID:
		return m.OldReceiptID(ctx)
	case transaction.FieldUserID:
		return m.OldUserID(ctx)
	case transaction.FieldType:
		return m.OldType(ctx)
	case transaction.FieldAmount:
		return m.OldAmount(ctx)
	case transaction.FieldCurrency:
		return m.OldCurrency(ctx)
	case transaction.FieldTransactionDate:
		return m.OldTransactionDate(ctx)
	case transaction.FieldDescription:
		return m.OldDescription(ctx)
	case transaction.FieldMerchantName:
		return m.OldMerchantName(ctx)
	case transaction.FieldMerchantCategory:
		return m.OldMerchantCategory(ctx)
	case transaction.FieldPaymentMethod:
		return m.OldPaymentMethod(ctx)
	case transaction.FieldCardLastFour:
		return m.OldCardLastFour(ctx)
	case transaction.FieldReferenceNumber:
		return m.OldReferenceNumber(ctx)
	case transaction.FieldAuthorizationCode:
		return m.OldAuthorizationCode(ctx)
	case transaction.FieldStatus:
		return m.OldStatus(ctx)
	case transaction.FieldIsRecurring:
		return m.OldIsRecurring(ctx)
	case transaction.FieldRecurrencePattern:
		return m.OldRecurrencePattern(ctx)
	case transaction.FieldCategoryTags:
		return m.OldCategoryTags(ctx)
	case transaction.FieldMetadata:
		return m.OldMetadata(ctx)
	case transaction.FieldNotes:
		return m.OldNotes(ctx)
	case transaction.FieldLegacyID:
		return m.OldLegacyID(ctx)
	case transaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case transaction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Transaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldReceiptID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiptID(v)
		return nil
	case transaction.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case transaction.FieldType:
		v, ok := value.(transaction.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case transaction.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case transaction.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case transaction.FieldTransactionDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionDate(v)
		return nil
	case transaction.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case transaction.FieldMerchantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantName(v)
		return nil
	case transaction.FieldMerchantCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantCategory(v)
		return nil
	case transaction.FieldPaymentMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentMethod(v)
		return nil
	case transaction.FieldCardLastFour:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCardLastFour(v)
		return nil
	case transaction.FieldReferenceNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceNumber(v)
		return nil
	case transaction.FieldAuthorizationCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorizationCode(v)
		return nil
	case transaction.FieldStatus:
		v, ok := value.(transaction.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case transaction.FieldIsRecurring:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRecurring(v)
		return nil
	case transaction.FieldRecurrencePattern:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecurrencePattern(v)
		return nil
	case transaction.FieldCategoryTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryTags(v)
		return nil
	case transaction.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case transaction.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case transaction.FieldLegacyID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLegacyID(v)
		return nil
	case transaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case transaction.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, transaction.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transaction.FieldDescription) {
		fields = append(fields, transaction.FieldDescription)
	}
	if m.FieldCleared(transaction.FieldMerchantName) {
		fields = append(fields, transaction.FieldMerchantName)
	}
	if m.FieldCleared(transaction.FieldMerchantCategory) {
		fields = append(fields, transaction.FieldMerchantCategory)
	}
	if m.FieldCleared(transaction.FieldPaymentMethod) {
		fields = append(fields, transaction.FieldPaymentMethod)
	}
	if m.FieldCleared(transaction.FieldCardLastFour) {
		fields = append(fields, transaction.FieldCardLastFour)
	}
	if m.FieldCleared(transaction.FieldReferenceNumber) {
		fields = append(fields, transaction.FieldReferenceNumber)
	}
	if m.FieldCleared(transaction.FieldAuthorizationCode) {
		fields = append(fields, transaction.FieldAuthorizationCode)
	}
	if m.FieldCleared(transaction.FieldRecurrencePattern) {
		fields = append(fields, transaction.FieldRecurrencePattern)
	}
	if m.FieldCleared(transaction.FieldCategoryTags) {
		fields = append(fields, transaction.FieldCategoryTags)
	}
	if m.FieldCleared(transaction.FieldMetadata) {
		fields = append(fields, transaction.FieldMetadata)
	}
	if m.FieldCleared(transaction.FieldNotes) {
		fields = append(fields, transaction.FieldNotes)
	}
	if m.FieldCleared(transaction.FieldLegacyID) {
		fields = append(fields, transaction.FieldLegacyID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionMutation) ClearField(name string) error {
	switch name {
	case transaction.FieldDescription:
		m.ClearDescription()
		return nil
	case transaction.FieldMerchantName:
		m.ClearMerchantName()
		return nil
	case transaction.FieldMerchantCategory:
		m.ClearMerchantCategory()
		return nil
	case transaction.FieldPaymentMethod:
		m.ClearPaymentMethod()
		return nil
	case transaction.FieldCardLastFour:
		m.ClearCardLastFour()
		return nil
	case transaction.FieldReferenceNumber:
		m.ClearReferenceNumber()
		return nil
	case transaction.FieldAuthorizationCode:
		m.ClearAuthorizationCode()
		return nil
	case transaction.FieldRecurrencePattern:
		m.ClearRecurrencePattern()
		return nil
	case transaction.FieldCategoryTags:
		m.ClearCategoryTags()
		return nil
	case transaction.FieldMetadata:
		m.ClearMetadata()
		return nil
	case transaction.FieldNotes:
		m.ClearNotes()
		return nil
	case transaction.FieldLegacyID:
		m.ClearLegacyID()
		return nil
	}
	return fmt.Errorf("unknown Transaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionMutation) ResetField(name string) error {
	switch name {
	case transaction.FieldReceiptID:
		m.ResetReceiptID()
		return nil
	case transaction.FieldUserID:
		m.ResetUserID()
		return nil
	case transaction.FieldType:
		m.ResetType()
		return nil
	case transaction.FieldAmount:
		m.ResetAmount()
		return nil
	case transaction.FieldCurrency:
		m.ResetCurrency()
		return nil
	case transaction.FieldTransactionDate:
		m.ResetTransactionDate()
		return nil
	case transaction.FieldDescription:
		m.ResetDescription()
		return nil
	case transaction.FieldMerchantName:
		m.ResetMerchantName()
		return nil
	case transaction.FieldMerchantCategory:
		m.ResetMerchantCategory()
		return nil
	case transaction.FieldPaymentMethod:
		m.ResetPaymentMethod()
		return nil
	case transaction.FieldCardLastFour:
		m.ResetCardLastFour()
		return nil
	case transaction.FieldReferenceNumber:
		m.ResetReferenceNumber()
		return nil
	case transaction.FieldAuthorizationCode:
		m.ResetAuthorizationCode()
		return nil
	case transaction.FieldStatus:
		m.ResetStatus()
		return nil
	case transaction.FieldIsRecurring:
		m.ResetIsRecurring()
		return nil
	case transaction.FieldRecurrencePattern:
		m.ResetRecurrencePattern()
		return nil
	case transaction.FieldCategoryTags:
		m.ResetCategoryTags()
		return nil
	case transaction.FieldMetadata:
		m.ResetMetadata()
		return nil
	case transaction.FieldNotes:
		m.ResetNotes()
		return nil
	case transaction.FieldLegacyID:
		m.ResetLegacyID()
		return nil
	case transaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case transaction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.receipt != nil {
		edges = append(edges, transaction.EdgeReceipt)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transaction.EdgeReceipt:
		if id := m.receipt; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedreceipt {
		edges = append(edges, transaction.EdgeReceipt)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionMutation) EdgeCleared(name string) bool {
	switch name {
	case transaction.EdgeReceipt:
		return m.clearedreceipt
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionMutation) ClearEdge(name string) error {
	switch name {
	case transaction.EdgeReceipt:
		m.ClearReceipt()
		return nil
	}
	return fmt.Errorf("unknown Transaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionMutation) ResetEdge(name string) error {
	switch name {
	case transaction.EdgeReceipt:
		m.ResetReceipt()
		return nil
	}
	return fmt.Errorf("unknown Transaction edge %s", name)
}
